{"title":"Fisher Scoring dan IRLS untuk GLM dengan variabel respon biner","markdown":{"yaml":{"title":"Fisher Scoring dan IRLS untuk GLM dengan variabel respon biner","date":"9-10-2023","author":"Gerry Alfa Dito","categories":["GLM","R Programming","Computational Statistics"],"draft":false,"image":"post-image.jpg"},"headingText":"Package","containsRefs":false,"markdown":"\n\n\n```{r message=FALSE,warning=FALSE}\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(broom)\n```\n\n\n## Fisher Scoring untuk GLM\n\n\nFormula Fisher Scoring yang digunakan untuk mendapatkan penduga bagi koefisien GLM adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\ndengan\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}^{(i)}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)} (\\boldsymbol{D}_{n \\times n}^{(i)})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1}^{(i)})\n$$ \ndan \n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)}=\\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan Score function $\\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$  dan Expected Fisher Information $\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} $saat stopping criterion terpenuhi\n\n\n\n## Iteratively reweighted least squares (IRLS) untuk GLM\n\nIRLS untuk GLM merupakan hasil reformulasi dari Fisher Scoring untuk GLM. Berikut proses penurunanya\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+[\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} ]^{−1} \\boldsymbol{S}_{(𝑝+1)×1}^{(i)} \\\\\n   \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}  \\boldsymbol{\\beta}_{(𝑝+1)×1}^{(𝑖+1)}              &= \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\boldsymbol{S}_{(𝑝+1)×1}^{(i)}\n\\end{aligned}\n$$\n\nkemudiann dengan mensubtitusikan $\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}$ dan $\\boldsymbol{S}_{(𝑝+1)×1}^{(i)}$ sesuai dengan definisi yang ada di fisher scoring, didapat\n\n\n\n$$\n\\begin{aligned}\n \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}              &=  \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\left[ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &= \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\left[\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &\\text{ misal }  \\boldsymbol{z}_{n \\times1}=\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)})  \\\\\n &=\\boldsymbol{X}_{(p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nmaka diperoleh persamaan normal (normal equation) sebagai berikut:\n\n\n\n$$\n\\begin{aligned}\n\\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)} \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)} \\\\\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  &= \\left\\{ \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nKemudian, solusi dari persamaan normal diatas adalah\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\njadi, formulasi untuk IRLS adalah \n\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan $\\boldsymbol{W}_{n \\times n}^{(0)}$  dan $\\boldsymbol{z}_{n \\times1}^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{z}_{n \\times1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$saat stopping criterion terpenuhi\n\n\n\n\n## Data\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nread_delim(delim = \";\",file =\n  'No;Variabel;Keterangan\n   1;age;umur nasabah(numeric)\n   2;job;jenis pekerjaan nasabah(categorical:\"admin.\",\"unknown\",\"unemployed\",\"management\",\"housemaid\",\"entrepreneur\",\"student\",\"blue-collar\",\"self-employed\",\"retired\",\"technician\",\"services\") \n   3;marital;status perkawinan nasabah (categorical: \"married\",\"divorced\",\"single\")\n   4;education;tingkat pendidikan(categorical: \"unknown\",\"secondary\",\"primary\",\"tertiary\")\n   5;default;apakah nasabah memiliki kredit yang macet? (binary: \"yes\",\"no\")\n   6;balance;saldo tahunan rata-rata dalam euros (numeric) \n   7;housing;apakah nasabah memiliki cicilan rumah? (binary: \"yes\",\"no\")\n   8;loan;apakah nasabah memiliki pinjaman pribadi? (binary: \"yes\",\"no\")\n   9;contact;perangkat telekomunikasi (categorical: \"unknown\",\"telephone\",\"cellular\") \n   10;duration;durasi panggilan terakhir, dalam detik (numeric)\n  11;pdays; banyaknya hari yang telah berlalu setelah klien terakhir kali dihubungi dari campaign sebelumnya (angka, -1 berarti klien tidak dihubungi sebelumnya)\n  12;previous;banyaknya komunikasi yang dilakukan sebelum campaign ini(numeric)\n  13;poutcome;hasil dari promosi campaign sebelumnya (categorical: \"unknown\",\"other\",\"failure\",\"success\")\n  14;subscribed;response variable (desired target),apakah nasabah telah berlangganan deposito berjangka? (binary: \"yes\",\"no\")') %>% \n  gt::gt()\n```\n\n\nData bisa didownload di link berikut\n\n\n[Download Data](https://drive.google.com/file/d/11e5IwdRsIepcUwS6OQQAdYb6_6mJsKSD/view?usp=drive_link)\n  \n## Import Data\n\n```{r}\nbank_marketing <- read.csv(\"bank_marketing.csv\",stringsAsFactors = TRUE)\n```\n\n```{r}\nglimpse(bank_marketing)\n```\n\n\n## Fisher Scoring dan IRLS untuk Binomial GLM\n\n\nMisal Binomial GLM didefinisikan sebagai\n\n\n$$\n\\boldsymbol{\\pi} = \\frac{\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}{1+\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}\n$$\natau\n\n$$\n\\text{logit}(\\boldsymbol{\\pi}) = \\log{ \\left( \\frac{\\boldsymbol{\\pi}}{1-\\boldsymbol{\\pi}} \\right)}= \\boldsymbol{X}\\boldsymbol{\\beta} \n$$\ndengan \n\n$$\n\\boldsymbol{\\pi}=P(\\boldsymbol{y}=1)\n$$\n\n\nUntuk ilustrasi penggunaan Fisher-scoring dan IRLS kita akan menggunakan variabel prediktor `balance`, `age`, `housing` dan `marital`\n\n\n```{r}\nset.seed(2045)\nbank_marketing_mini <-  bank_marketing %>% \n                            select(subscribed,balance,age,housing,marital) %>% \n                            slice_sample(n=250,by = subscribed)\nglimpse(bank_marketing_mini)\n```\n\n\nKemudian kita akan ekstrak matriks modelnya $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n```{r}\nX <- model.matrix(subscribed~balance+age+housing+marital,data = bank_marketing_mini)\n#dimensi matrix X\ndim(X)\n```\n\n\ndan kemudian untuk $\\boldsymbol{y}_{n\\times 1}$, kita misalkan kategori `yes` sebagai 1 dan 0 adalah untuk kategori `no`  \n\n\n```{r}\ny <- ifelse(bank_marketing_mini$subscribed==\"yes\",1,0)\n# ukuran variabel respon\nlength(y)\n# banyaknya nilai 1 dan 0\ntable(y)\n```\n\nberikut overview dari matriks $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n```{r}\nX[1:10,]\n```\n\n\n### Binomial sebagai distribusi keluarga eksponensial\n\nSelanjutnya kita akan mendefinisikan matriks-matriks lain yang dibutuhkan untuk fisher scoring dan IRLS. Pertama-tama kita ingat terlebih dahulu tentang distribusi binomail sebagai distribusi keluarga eksponensial.\n\nDistribusi Binomial yang digunakan untuk GLM adalah $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$. Ingat bahwa, Cumulant function $b(\\theta)$ untuk $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$ adalah\n\n\n$$\nb(\\theta) = \\log{[1 + \\exp{(\\theta})]}\n$$\n\n\ndan parameter dispersi $a(\\phi)$\n\n\n\n$$\na(\\phi)=\\frac{1}{m}\n$$\n\n\nKemudian, $\\mu$ dan $Var(Y)$ dari $Y\\frac{\\text{Binomial}(m,\\pi)}{m}$ sebagai keluarga eksponensial adalah\n\n\n$$\n\\begin{aligned}\n\\mu=E(Y)    &= \\frac{d b(\\theta)}{d\\theta} \\\\\n            &=\\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}}\n\\end{aligned}\n$$\n\ndan\n\n$$\n\\begin{aligned}\n\nVar(Y) &= Var(\\mu) a(\\phi) \\\\\n       &=  \\frac{d ^{2}b(\\theta)}{d\\theta^{2}} a(\\phi)\\\\\n       &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m}\n\\end{aligned}\n$$\n\nIngat bahwa koneksi (pemisalan) $\\theta$ dengan parameter $\\pi$ adalah sebagai berikut\n\n\n$$\n\\theta            =    \\log{ \\left( \\frac{\\pi}{1-\\pi} \\right)} \n$$\n\nJika kita subtitusi ke dalam $\\mu$ dan $Var(Y)$\n\n\n$$\n\\begin{aligned}\n\\mu &= \\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}} \\\\\n    &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{1 +  \\left( \\frac{\\pi}{1-\\pi} \\right)} \\\\\n    &= \\pi\n\\end{aligned}\n$$\n\n\n$$\n\\begin{aligned}\nVar(Y) &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m} \\\\\n       &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{ \\left[1 +  \\left( \\frac{\\pi}{1-\\pi} \\right) \\right]^{2}} \\frac{1}{m} \\\\\n       &= \\pi (1-\\pi) \\frac{1}{m} \\\\\n       &= \\frac{\\pi (1-\\pi)}{m}\n\\end{aligned}\n$$\n\n\njadi $\\mu=\\pi$ dan $Var(Y)=\\frac{\\pi (1-\\pi)}{m}$. Kemudian, fungsi hubung (link function) yang digunakan adalah fungsi hubung kanonik (canonical link function) yaitu\n\n\n$$\n\\eta=\\text{logit}(\\mu)=\\text{logit}(\\pi)=\\log{\\left( \\frac{\\pi}{1-\\pi} \\right)}\n$$\n\njika kita ubah menjadi fungsi dari $\\eta$\n\n$$\ng^{-1}(\\eta)=\\mu=\\pi = \\frac{\\exp{(\\eta)}}{1+\\exp{(\\eta)}}\n$$\n\n\n\n### Mendefiniskan matriks untuk Fisher Scoring dan IRLS\n\n\nKemudian kita akan dapatkan matriks $\\boldsymbol{W}_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{W}_{n \\times n} = \\begin{bmatrix}\n \\frac{\\left(\\frac{d \\mu_{1}}{d\\eta_{1}} \\right)^{2}}{Var(y_{1})}  & 0 & \\ldots & 0 \\\\\n 0 & \\frac{\\left(\\frac{d \\mu_{2}}{d\\eta_{2}} \\right)^{2}}{Var(y_{2})}  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{\\left(\\frac{d \\mu_{n}}{d\\eta_{2}} \\right)^{2}}{Var(y_{n})}\n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\ndan \n\n\n$$\nVar(y_{i})= \\frac{\\pi_i (1-\\pi_i)}{m_i}\n$$\n\n\nsehingga\n\n\n$$\n\\frac{\\left(\\frac{d \\mu_{i}}{d\\eta_{i}} \\right)^{2}}{Var(y_{i})} = \\frac{[\\pi_i (1-\\pi_i)]^{2}}{\\frac{\\pi_i (1-\\pi_i)}{m_i}} = m_i\\pi_i (1-\\pi_i)\n$$\n\n\n\nJadi matriks $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{W}_{n \\times n}= \\begin{bmatrix}\n m_{1}\\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & m_{2}\\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & m_{n}\\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\nkita tuliskan matriks $\\boldsymbol{W}_{n \\times n}$ dalam sintaks R\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\nmisalkan  $m_1=m_2=m_3=1$ dan $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n```{r}\nW(m=c(1,1,1),pi=c(0.5,0.6,0.7))\n```\n\n\nSelanjutnya kita akan dapatkan matriks $D_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{D}_{n \\times n} = \\begin{bmatrix}\n \\frac{d \\mu_{1}}{d\\eta_{1}}   & 0 & \\ldots & 0 \\\\\n 0 & \\frac{d \\mu_{2}}{d\\eta_{2}}   & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{d \\mu_{n}}{d\\eta_{n}} \n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\n\n\nJadi matriks $\\boldsymbol{D}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{D}_{n \\times n}= \\begin{bmatrix}\n \\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & \\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\n\nkita tuliskan matriks $\\boldsymbol{D}_{n \\times n}$ dalam sintaks R\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\nmisalkan  $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{D}_{n \\times n}$ adalah\n\n```{r}\nD(pi=c(0.5,0.6,0.7))\n```\n\n\n\nSelanjutnya kita akan dapatkan matriks $\\boldsymbol{\\mu}_{n \\times 1}$ yang didefinisikan\n\n$$\n\\boldsymbol{\\mu}_{n \\times 1}=g^{-1}(\\boldsymbol{X}\\boldsymbol{\\beta})=\\frac{\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}{1+\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}\n$$\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\nmisalkan  $\\boldsymbol{X}_{n \\times (p+1)}$ berasal dari data `bank_marketing_mini` dan $\\boldsymbol{\\beta}_{(p+1)}=[0.230  0.001 \\space 0.002 \\space -0.769 \\space -0.166 \\space 0.109]^{t}$ maka $\\boldsymbol{\\mu}_{n \\times 1}$ adalah\n\n\n```{r}\n# memeriksa dimensi\ndim( mu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) ) )\n# menampilkan 10 elemen pertama\nmu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) )[1:10]\n```\n\n\n### Fisher Scoring\n\n\n\nmatriks $\\boldsymbol{S}_{(p+1) \\times 1}$ adalah\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1})\n$$   \n\n\nkita tuliskan matriks $\\boldsymbol{S}_{(p+1) \\times 1}$ dalam sintaks R\n\n\n```{r}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(D_coba)\nD_coba[1:5,1:5]\n\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\nhead(mu_coba)\n```\n\n\n\n```{r}\nS(X = X,W = W_coba,D = D_coba,y = y,mu = mu_coba)\n```\n\n\nmatriks $\\boldsymbol{\\mathcal{I}}_{p \\times p}$ adalah\n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }=\\boldsymbol{X}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\nkita tuliskan matriks $\\boldsymbol{\\mathcal{I}}_{p \\times p }$ dalam sintaks R\n\n\n```{r}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n\n\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n```\n\n\n```{r}\nI_fs(X = X,W = W_coba)[1:5,1:5]\n```\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\n\n\n```{r}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n\n\n\n```{r}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi fisher scoring\n\n\n\n\n\n```{r}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$, nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n```{r}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n\n\nIngat Formula Fisher Scoring yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\n\n```{r}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  I_inv <- chol2inv(chol( I_fs(X = X,W = W_new) ))\n  \n  #formulasi fisher scoring\n  beta_new <- beta_new +I_inv %*% S(X=X,W = W_new,D = D_new,y =y ,mu = mu_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n\n\n\nSaat Convergent maka kita mendapatkan\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})= \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}\n$$\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}$.\n\n\n```{r}\nresult_fs <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=I_inv)\nresult_fs$iter_convergence\nresult_fs$var_beta\nsummary_fs <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_fs$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_fs$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_fs\n```\n\n\n\n\n### IRLS\n\n\nmatriks $\\boldsymbol{z}$ adalah\n\n\n$$\n\\boldsymbol{z}_{n \\times 1}=\\boldsymbol{X}_{ n \\times (p+1) }\\boldsymbol{\\beta}_{((𝑝+1)×1)} + (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1})\n$$\n\nkita tuliskan matriks $\\boldsymbol{z}$ dalam sintaks R\n\n\n```{r}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{\\beta}_{((𝑝+1)×1)},\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n\nbeta_coba <- c(0.230,0.001,0.002,-0.769,-0.166,0.109)\nbeta_coba\n\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(mu_coba)\nD_coba[1:5,1:5]\n\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\nhead(mu_coba)\n```\n\n\n\n```{r}\nz_coba <- z(X = X,beta = beta_coba,D = D_coba,y = y,mu = mu_coba)\ndim(z_coba)\nz_coba[1:10]\n```\n\n\n\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\n\n\n```{r}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi IRLS\n\n\n\n\n\n```{r}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$ nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n```{r}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n\n\nIngat Formula IRLS yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\n\n```{r}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  z_new <- z(X = X,beta = beta_new,D = D_new,y = y,mu = mu_new)\n  inv_XWX <- chol2inv(chol(crossprod(X,W_new %*% X)))\n  \n  #formulasi fisher scoring\n  beta_new <- inv_XWX %*% crossprod(X,W_new %*% z_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n\n\n\nSaat Convergent maka kita mendapatkan\n\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})=  \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}\n$$\n\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$.\n\n\n```{r}\nresult_irls <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=inv_XWX)\nresult_irls$iter_convergence\nresult_irls$var_beta\nsummary_irls <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_irls$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_irls$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_irls\n```\n\n\n### Default fungsi R\n\n\n```{r}\nmod1 <- glm(formula = subscribed~.,\n            data = bank_marketing_mini,\n            family = binomial(link = \"logit\"))\n```\n\n\n```{r}\ntidy(mod1) %>% \n  mutate(across(where(is.numeric),function(x) round(x,7)))\n```\n\n","srcMarkdownNoYaml":"\n\n## Package\n\n```{r message=FALSE,warning=FALSE}\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(broom)\n```\n\n\n## Fisher Scoring untuk GLM\n\n\nFormula Fisher Scoring yang digunakan untuk mendapatkan penduga bagi koefisien GLM adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\ndengan\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}^{(i)}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)} (\\boldsymbol{D}_{n \\times n}^{(i)})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1}^{(i)})\n$$ \ndan \n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)}=\\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan Score function $\\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$  dan Expected Fisher Information $\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} $saat stopping criterion terpenuhi\n\n\n\n## Iteratively reweighted least squares (IRLS) untuk GLM\n\nIRLS untuk GLM merupakan hasil reformulasi dari Fisher Scoring untuk GLM. Berikut proses penurunanya\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+[\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} ]^{−1} \\boldsymbol{S}_{(𝑝+1)×1}^{(i)} \\\\\n   \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}  \\boldsymbol{\\beta}_{(𝑝+1)×1}^{(𝑖+1)}              &= \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\boldsymbol{S}_{(𝑝+1)×1}^{(i)}\n\\end{aligned}\n$$\n\nkemudiann dengan mensubtitusikan $\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}$ dan $\\boldsymbol{S}_{(𝑝+1)×1}^{(i)}$ sesuai dengan definisi yang ada di fisher scoring, didapat\n\n\n\n$$\n\\begin{aligned}\n \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}              &=  \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\left[ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &= \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\left[\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &\\text{ misal }  \\boldsymbol{z}_{n \\times1}=\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)})  \\\\\n &=\\boldsymbol{X}_{(p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nmaka diperoleh persamaan normal (normal equation) sebagai berikut:\n\n\n\n$$\n\\begin{aligned}\n\\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)} \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)} \\\\\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  &= \\left\\{ \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nKemudian, solusi dari persamaan normal diatas adalah\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\njadi, formulasi untuk IRLS adalah \n\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan $\\boldsymbol{W}_{n \\times n}^{(0)}$  dan $\\boldsymbol{z}_{n \\times1}^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{z}_{n \\times1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$saat stopping criterion terpenuhi\n\n\n\n\n## Data\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nread_delim(delim = \";\",file =\n  'No;Variabel;Keterangan\n   1;age;umur nasabah(numeric)\n   2;job;jenis pekerjaan nasabah(categorical:\"admin.\",\"unknown\",\"unemployed\",\"management\",\"housemaid\",\"entrepreneur\",\"student\",\"blue-collar\",\"self-employed\",\"retired\",\"technician\",\"services\") \n   3;marital;status perkawinan nasabah (categorical: \"married\",\"divorced\",\"single\")\n   4;education;tingkat pendidikan(categorical: \"unknown\",\"secondary\",\"primary\",\"tertiary\")\n   5;default;apakah nasabah memiliki kredit yang macet? (binary: \"yes\",\"no\")\n   6;balance;saldo tahunan rata-rata dalam euros (numeric) \n   7;housing;apakah nasabah memiliki cicilan rumah? (binary: \"yes\",\"no\")\n   8;loan;apakah nasabah memiliki pinjaman pribadi? (binary: \"yes\",\"no\")\n   9;contact;perangkat telekomunikasi (categorical: \"unknown\",\"telephone\",\"cellular\") \n   10;duration;durasi panggilan terakhir, dalam detik (numeric)\n  11;pdays; banyaknya hari yang telah berlalu setelah klien terakhir kali dihubungi dari campaign sebelumnya (angka, -1 berarti klien tidak dihubungi sebelumnya)\n  12;previous;banyaknya komunikasi yang dilakukan sebelum campaign ini(numeric)\n  13;poutcome;hasil dari promosi campaign sebelumnya (categorical: \"unknown\",\"other\",\"failure\",\"success\")\n  14;subscribed;response variable (desired target),apakah nasabah telah berlangganan deposito berjangka? (binary: \"yes\",\"no\")') %>% \n  gt::gt()\n```\n\n\nData bisa didownload di link berikut\n\n\n[Download Data](https://drive.google.com/file/d/11e5IwdRsIepcUwS6OQQAdYb6_6mJsKSD/view?usp=drive_link)\n  \n## Import Data\n\n```{r}\nbank_marketing <- read.csv(\"bank_marketing.csv\",stringsAsFactors = TRUE)\n```\n\n```{r}\nglimpse(bank_marketing)\n```\n\n\n## Fisher Scoring dan IRLS untuk Binomial GLM\n\n\nMisal Binomial GLM didefinisikan sebagai\n\n\n$$\n\\boldsymbol{\\pi} = \\frac{\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}{1+\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}\n$$\natau\n\n$$\n\\text{logit}(\\boldsymbol{\\pi}) = \\log{ \\left( \\frac{\\boldsymbol{\\pi}}{1-\\boldsymbol{\\pi}} \\right)}= \\boldsymbol{X}\\boldsymbol{\\beta} \n$$\ndengan \n\n$$\n\\boldsymbol{\\pi}=P(\\boldsymbol{y}=1)\n$$\n\n\nUntuk ilustrasi penggunaan Fisher-scoring dan IRLS kita akan menggunakan variabel prediktor `balance`, `age`, `housing` dan `marital`\n\n\n```{r}\nset.seed(2045)\nbank_marketing_mini <-  bank_marketing %>% \n                            select(subscribed,balance,age,housing,marital) %>% \n                            slice_sample(n=250,by = subscribed)\nglimpse(bank_marketing_mini)\n```\n\n\nKemudian kita akan ekstrak matriks modelnya $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n```{r}\nX <- model.matrix(subscribed~balance+age+housing+marital,data = bank_marketing_mini)\n#dimensi matrix X\ndim(X)\n```\n\n\ndan kemudian untuk $\\boldsymbol{y}_{n\\times 1}$, kita misalkan kategori `yes` sebagai 1 dan 0 adalah untuk kategori `no`  \n\n\n```{r}\ny <- ifelse(bank_marketing_mini$subscribed==\"yes\",1,0)\n# ukuran variabel respon\nlength(y)\n# banyaknya nilai 1 dan 0\ntable(y)\n```\n\nberikut overview dari matriks $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n```{r}\nX[1:10,]\n```\n\n\n### Binomial sebagai distribusi keluarga eksponensial\n\nSelanjutnya kita akan mendefinisikan matriks-matriks lain yang dibutuhkan untuk fisher scoring dan IRLS. Pertama-tama kita ingat terlebih dahulu tentang distribusi binomail sebagai distribusi keluarga eksponensial.\n\nDistribusi Binomial yang digunakan untuk GLM adalah $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$. Ingat bahwa, Cumulant function $b(\\theta)$ untuk $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$ adalah\n\n\n$$\nb(\\theta) = \\log{[1 + \\exp{(\\theta})]}\n$$\n\n\ndan parameter dispersi $a(\\phi)$\n\n\n\n$$\na(\\phi)=\\frac{1}{m}\n$$\n\n\nKemudian, $\\mu$ dan $Var(Y)$ dari $Y\\frac{\\text{Binomial}(m,\\pi)}{m}$ sebagai keluarga eksponensial adalah\n\n\n$$\n\\begin{aligned}\n\\mu=E(Y)    &= \\frac{d b(\\theta)}{d\\theta} \\\\\n            &=\\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}}\n\\end{aligned}\n$$\n\ndan\n\n$$\n\\begin{aligned}\n\nVar(Y) &= Var(\\mu) a(\\phi) \\\\\n       &=  \\frac{d ^{2}b(\\theta)}{d\\theta^{2}} a(\\phi)\\\\\n       &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m}\n\\end{aligned}\n$$\n\nIngat bahwa koneksi (pemisalan) $\\theta$ dengan parameter $\\pi$ adalah sebagai berikut\n\n\n$$\n\\theta            =    \\log{ \\left( \\frac{\\pi}{1-\\pi} \\right)} \n$$\n\nJika kita subtitusi ke dalam $\\mu$ dan $Var(Y)$\n\n\n$$\n\\begin{aligned}\n\\mu &= \\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}} \\\\\n    &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{1 +  \\left( \\frac{\\pi}{1-\\pi} \\right)} \\\\\n    &= \\pi\n\\end{aligned}\n$$\n\n\n$$\n\\begin{aligned}\nVar(Y) &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m} \\\\\n       &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{ \\left[1 +  \\left( \\frac{\\pi}{1-\\pi} \\right) \\right]^{2}} \\frac{1}{m} \\\\\n       &= \\pi (1-\\pi) \\frac{1}{m} \\\\\n       &= \\frac{\\pi (1-\\pi)}{m}\n\\end{aligned}\n$$\n\n\njadi $\\mu=\\pi$ dan $Var(Y)=\\frac{\\pi (1-\\pi)}{m}$. Kemudian, fungsi hubung (link function) yang digunakan adalah fungsi hubung kanonik (canonical link function) yaitu\n\n\n$$\n\\eta=\\text{logit}(\\mu)=\\text{logit}(\\pi)=\\log{\\left( \\frac{\\pi}{1-\\pi} \\right)}\n$$\n\njika kita ubah menjadi fungsi dari $\\eta$\n\n$$\ng^{-1}(\\eta)=\\mu=\\pi = \\frac{\\exp{(\\eta)}}{1+\\exp{(\\eta)}}\n$$\n\n\n\n### Mendefiniskan matriks untuk Fisher Scoring dan IRLS\n\n\nKemudian kita akan dapatkan matriks $\\boldsymbol{W}_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{W}_{n \\times n} = \\begin{bmatrix}\n \\frac{\\left(\\frac{d \\mu_{1}}{d\\eta_{1}} \\right)^{2}}{Var(y_{1})}  & 0 & \\ldots & 0 \\\\\n 0 & \\frac{\\left(\\frac{d \\mu_{2}}{d\\eta_{2}} \\right)^{2}}{Var(y_{2})}  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{\\left(\\frac{d \\mu_{n}}{d\\eta_{2}} \\right)^{2}}{Var(y_{n})}\n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\ndan \n\n\n$$\nVar(y_{i})= \\frac{\\pi_i (1-\\pi_i)}{m_i}\n$$\n\n\nsehingga\n\n\n$$\n\\frac{\\left(\\frac{d \\mu_{i}}{d\\eta_{i}} \\right)^{2}}{Var(y_{i})} = \\frac{[\\pi_i (1-\\pi_i)]^{2}}{\\frac{\\pi_i (1-\\pi_i)}{m_i}} = m_i\\pi_i (1-\\pi_i)\n$$\n\n\n\nJadi matriks $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{W}_{n \\times n}= \\begin{bmatrix}\n m_{1}\\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & m_{2}\\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & m_{n}\\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\nkita tuliskan matriks $\\boldsymbol{W}_{n \\times n}$ dalam sintaks R\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\nmisalkan  $m_1=m_2=m_3=1$ dan $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n```{r}\nW(m=c(1,1,1),pi=c(0.5,0.6,0.7))\n```\n\n\nSelanjutnya kita akan dapatkan matriks $D_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{D}_{n \\times n} = \\begin{bmatrix}\n \\frac{d \\mu_{1}}{d\\eta_{1}}   & 0 & \\ldots & 0 \\\\\n 0 & \\frac{d \\mu_{2}}{d\\eta_{2}}   & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{d \\mu_{n}}{d\\eta_{n}} \n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\n\n\nJadi matriks $\\boldsymbol{D}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{D}_{n \\times n}= \\begin{bmatrix}\n \\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & \\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\n\nkita tuliskan matriks $\\boldsymbol{D}_{n \\times n}$ dalam sintaks R\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\nmisalkan  $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{D}_{n \\times n}$ adalah\n\n```{r}\nD(pi=c(0.5,0.6,0.7))\n```\n\n\n\nSelanjutnya kita akan dapatkan matriks $\\boldsymbol{\\mu}_{n \\times 1}$ yang didefinisikan\n\n$$\n\\boldsymbol{\\mu}_{n \\times 1}=g^{-1}(\\boldsymbol{X}\\boldsymbol{\\beta})=\\frac{\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}{1+\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}\n$$\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\nmisalkan  $\\boldsymbol{X}_{n \\times (p+1)}$ berasal dari data `bank_marketing_mini` dan $\\boldsymbol{\\beta}_{(p+1)}=[0.230  0.001 \\space 0.002 \\space -0.769 \\space -0.166 \\space 0.109]^{t}$ maka $\\boldsymbol{\\mu}_{n \\times 1}$ adalah\n\n\n```{r}\n# memeriksa dimensi\ndim( mu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) ) )\n# menampilkan 10 elemen pertama\nmu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) )[1:10]\n```\n\n\n### Fisher Scoring\n\n\n\nmatriks $\\boldsymbol{S}_{(p+1) \\times 1}$ adalah\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1})\n$$   \n\n\nkita tuliskan matriks $\\boldsymbol{S}_{(p+1) \\times 1}$ dalam sintaks R\n\n\n```{r}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(D_coba)\nD_coba[1:5,1:5]\n\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\nhead(mu_coba)\n```\n\n\n\n```{r}\nS(X = X,W = W_coba,D = D_coba,y = y,mu = mu_coba)\n```\n\n\nmatriks $\\boldsymbol{\\mathcal{I}}_{p \\times p}$ adalah\n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }=\\boldsymbol{X}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\nkita tuliskan matriks $\\boldsymbol{\\mathcal{I}}_{p \\times p }$ dalam sintaks R\n\n\n```{r}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n\n\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n```\n\n\n```{r}\nI_fs(X = X,W = W_coba)[1:5,1:5]\n```\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\n\n\n```{r}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n\n\n\n```{r}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi fisher scoring\n\n\n\n\n\n```{r}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$, nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n```{r}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n\n\nIngat Formula Fisher Scoring yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\n\n```{r}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  I_inv <- chol2inv(chol( I_fs(X = X,W = W_new) ))\n  \n  #formulasi fisher scoring\n  beta_new <- beta_new +I_inv %*% S(X=X,W = W_new,D = D_new,y =y ,mu = mu_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n\n\n\nSaat Convergent maka kita mendapatkan\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})= \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}\n$$\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}$.\n\n\n```{r}\nresult_fs <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=I_inv)\nresult_fs$iter_convergence\nresult_fs$var_beta\nsummary_fs <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_fs$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_fs$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_fs\n```\n\n\n\n\n### IRLS\n\n\nmatriks $\\boldsymbol{z}$ adalah\n\n\n$$\n\\boldsymbol{z}_{n \\times 1}=\\boldsymbol{X}_{ n \\times (p+1) }\\boldsymbol{\\beta}_{((𝑝+1)×1)} + (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1})\n$$\n\nkita tuliskan matriks $\\boldsymbol{z}$ dalam sintaks R\n\n\n```{r}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{\\beta}_{((𝑝+1)×1)},\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n\n```{r}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\nW_coba[1:5,1:5]\n\nbeta_coba <- c(0.230,0.001,0.002,-0.769,-0.166,0.109)\nbeta_coba\n\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(mu_coba)\nD_coba[1:5,1:5]\n\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\nhead(mu_coba)\n```\n\n\n\n```{r}\nz_coba <- z(X = X,beta = beta_coba,D = D_coba,y = y,mu = mu_coba)\ndim(z_coba)\nz_coba[1:10]\n```\n\n\n\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n\n```{r}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n\n\n\n```{r}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n\n\n\n```{r}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n\n\n\n```{r}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi IRLS\n\n\n\n\n\n```{r}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n\n```{r}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$ nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n```{r}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n\n\nIngat Formula IRLS yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\n\n```{r}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  z_new <- z(X = X,beta = beta_new,D = D_new,y = y,mu = mu_new)\n  inv_XWX <- chol2inv(chol(crossprod(X,W_new %*% X)))\n  \n  #formulasi fisher scoring\n  beta_new <- inv_XWX %*% crossprod(X,W_new %*% z_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n\n\n\nSaat Convergent maka kita mendapatkan\n\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})=  \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}\n$$\n\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$.\n\n\n```{r}\nresult_irls <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=inv_XWX)\nresult_irls$iter_convergence\nresult_irls$var_beta\nsummary_irls <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_irls$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_irls$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_irls\n```\n\n\n### Default fungsi R\n\n\n```{r}\nmod1 <- glm(formula = subscribed~.,\n            data = bank_marketing_mini,\n            family = binomial(link = \"logit\"))\n```\n\n\n```{r}\ntidy(mod1) %>% \n  mutate(across(where(is.numeric),function(x) round(x,7)))\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js","embed-resources":true,"toc":true,"toc-depth":6},"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":{"light":"flatly","dark":"darkly"},"page-layout":"article","comments":{"hypothesis":{"theme":"clean","openSidebar":false}},"title":"Fisher Scoring dan IRLS untuk GLM dengan variabel respon biner","date":"9-10-2023","author":"Gerry Alfa Dito","categories":["GLM","R Programming","Computational Statistics"],"draft":false,"image":"post-image.jpg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}