{"title":"Regresi logistik dengan R","markdown":{"yaml":{"title":"Regresi logistik dengan R","date":"11-20-2023","author":"Gerry Alfa Dito","categories":["GLM","R Programming","Statistical Machine Learning"],"draft":false,"image":"post-image.jpeg"},"headingText":"Package","containsRefs":false,"markdown":"\n\n\n\n\n\n```{r eval=FALSE}\ninstall.packages(\"see\")\n```\n\n\n\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(broom.helpers)\nlibrary(skimr)\nlibrary(performance)\nlibrary(rsample)\nlibrary(yardstick)\nlibrary(DataExplorer)\n```\n\nSebenarnya Anda tidak perlu untuk load keseluruhan pakcage, Anda bisa menggunakan syntax `namapackage::fungsi` untuk menggunakan suatu fungsi dari suatu package di R, selama package tersebut sudah Anda Install.\n\n## Data\n\nData ini terkait dengan promosi marketing langsung dari suatu institusi perbankan Portugal.  Promosi marketing tersebut didasarkan pada panggilan telepon. Sering kali, diperlukan lebih dari satu kali kontak ke klien yang sama, untuk memastikan apakah produk (deposito berjangka bank) akan (atau tidak) berlangganan. \n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nread_delim(delim = \";\",file =\n  'No;Variabel;Keterangan\n   1;age;umur nasabah(numeric)\n   2;job;jenis pekerjaan nasabah(categorical:\"admin.\",\"unknown\",\"unemployed\",\"management\",\"housemaid\",\"entrepreneur\",\"student\",\"blue-collar\",\"self-employed\",\"retired\",\"technician\",\"services\") \n   3;marital;status perkawinan nasabah (categorical: \"married\",\"divorced\",\"single\")\n   4;education;tingkat pendidikan(categorical: \"unknown\",\"secondary\",\"primary\",\"tertiary\")\n   5;default;apakah nasabah memiliki kredit yang macet? (binary: \"yes\",\"no\")\n   6;balance;saldo tahunan rata-rata dalam euros (numeric) \n   7;housing;apakah nasabah memiliki cicilan rumah? (binary: \"yes\",\"no\")\n   8;loan;apakah nasabah memiliki pinjaman pribadi? (binary: \"yes\",\"no\")\n   9;contact;perangkat telekomunikasi (categorical: \"unknown\",\"telephone\",\"cellular\") \n   10;duration;durasi panggilan terakhir, dalam detik (numeric)\n  11;pdays; banyaknya hari yang telah berlalu setelah klien terakhir kali dihubungi dari campaign sebelumnya (angka, -1 berarti klien tidak dihubungi sebelumnya)\n  12;previous;banyaknya komunikasi yang dilakukan sebelum campaign ini(numeric)\n  13;poutcome;hasil dari promosi campaign sebelumnya (categorical: \"unknown\",\"other\",\"failure\",\"success\")\n  14;subscribed;response variable (desired target),apakah nasabah telah berlangganan deposito berjangka? (binary: \"yes\",\"no\")') %>% \n  gt::gt()\n```\n\n\n[Download Data](https://drive.google.com/file/d/11e5IwdRsIepcUwS6OQQAdYb6_6mJsKSD/view?usp=drive_link)\n\n  \n## Import Data\n\n```{r}\nbank_marketing <- read_csv(\"bank_marketing.csv\")\n```\n\n```{r}\nglimpse(bank_marketing)\n```\n\nkarena fungsi `glm` untuk membutuhkan semua variabel (kolom) kategorik (biner atau nominal) dalam tipe data `factor` maka kita akan konversi terlebih dahulu.\n\n\n```{r}\nbank_marketing <- bank_marketing %>% \n              mutate(across(where(is.character),.fns =as.factor))\nglimpse(bank_marketing)\n```\n\n\n\n\n## Eksplorasi Data\n\n### Menggunakan Ringkasan Statistik\n\n\n```{r}\nskim_without_charts(data = bank_marketing)\n```\n\n### Menggunakan Visualisasi\n\n\n### Eksplorasi Umum\n\n```{r}\nplot_intro(data = bank_marketing,\n           ggtheme = theme_classic(),\n           theme_config = list(axis.line=element_blank(),\n                               axis.ticks=element_blank(),\n                               axis.text.x=element_blank(),\n                               axis.title=element_blank()\n                               )  \n           )\n```\n\n\n#### Eksplorasi Korelasi\n\n##### Korelasi variabel prediktor numerik dengan variabel response\n\n\n```{r}\nplot_boxplot(data = bank_marketing,by = \"subscribed\",\n             geom_boxplot_args = list(fill=\"#03A9F4\"),\n             ggtheme = theme_classic())\n```\n\n\n##### Korelasi variabel prediktor kategorik dengan variabel response\n\n\n```{r}\nplot_bar(data = bank_marketing,by = \"subscribed\",\n             ggtheme = theme_classic(),\n         ncol = 2)\n```\n\n## Pemodelan Regresi Logistik\n\n\n\n### Regresi Logistik Sederhana dengan variabel prediktor biner\n\n\nSecara umum model regresi logistik sederhana dapat ditulis:\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{x})}{1-\\pi(\\textbf{x})}\\right]} = \\beta_{0}+\\beta_{1}\\textbf{x}\n$$\n\ndimana:\n\n* $\\pi(\\textbf{x})=P(Y=1|\\pi(\\textbf{x}))$ dan $1-\\pi(\\textbf{x})=1-P(Y=1|\\pi(\\textbf{x}))=P(Y=0|\\pi(\\textbf{x}))$\n\n\natau dapat juga ditulis\n\n\n$$\n\\pi(\\textbf{x}) = \\frac{\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}{1+\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}\n$$\n\n\nPemodelan Regresi Logistik Sederhana dengan variabel prediktor biner perlu memperhatikan **reference category** atau **kategori pembanding** dari variabel prediktor biner tersebut. **Kategori pembanding** akan dikodekan dengan 0 dan kategori lainnya akan dikodekan dengan 1. Proses pengkodean ini sebenarnya adalah proses transformasi variabel biner menjadi variabel numerik. Variable hasil transformasi ini sering disebut dengan **variabel dummy** atau variabel yang amtan-amatannya hanya bernilai 1 atau 0.\n\n\nDalam R, **Kategori pembanding** ini biasanya merupakan kategori pertama yang ditunjukkan dari output fungsi `levels`. Berikut ilustrasinya\n\n```{r}\nlevels(bank_marketing$housing)\n```\n\nBerdasarkan output diatas, berarti **Kategori pembanding-nya** adalah `\"no\"` karena berada di urutan pertama. kita bisa merubah **Kategori pembanding** dengan fungsi `relevel` dan mengisi argumen `ref` dengan kategori yang akan dijadikan sebagai **kategori pembanding**. Berikut ilustrasinya\n\n\n```{r}\ncoba <- relevel(x = bank_marketing$housing,ref = \"yes\")\nlevels(coba)\n```\n\nKita bisa membandingkan proses transformasi variabel biner menjadi numerik 0 dan 1 menggunakan fungsi `contrast`\n\n```{r}\ncontrasts(bank_marketing$housing) %>% as.data.frame()\ncontrasts(coba) %>% as.data.frame()\n```\n\n\n\n\n\n\nfungsi `glm` dapat digunakan untuk menjalan regresi logistik.\n\n\n```{r}\nmod1 <-glm(subscribed==\"yes\"~housing,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n* sintaks `subscribed==\"yes\"` berarti kita menenetapkan kelas positifnya adalah `yes` atau $P(Y=1|\\pi(\\textbf{x}))$ sedangkan kelas negatifnya adalah `no`  atau $P(Y=0|\\pi(\\textbf{x}))$\n* jika kita tidak mendefinisikan dengan sintaks `subscribed==\"yes\"` maka secara default yang akan menjadi kelas positif adalah kategori pertama yang ditunjukkan dari output fungsi `levels`. Dalam kasus variabel respon `subscribed`, secara default yang menjadi kelas positif adalah `no`. Berikut cara mengecek kategori pertama dari `levels`.\n\n\n```{r}\nlevels(bank_marketing$subscribed)\n```\n\n* sintaks `~housing` menandakan bahwa `housing` adalah variabel prediktor.\n* sintaks `family(link = \"logit\")` digunakan untuk menandakan kita menggunakan regresi logistik.\n\n\n\nkemudian untuk mengeluarkan nilai dugaan koefisien, Selang kepercayaan (Confidence Interval) dan p-value dapat menggunakan fungsi `parameters` dari package `parameters`\n\n\n```{r}\ntidy_parameters(mod1,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n* Koefisien dari prediktor `housing [yes]` $(\\beta_{1})$ adalah $-0.88$ (negatif) berarti **saat nasabah memiliki cicilan rumah maka kemungkinan nasabah tidak akan berlangganan deposito berjangka**.\n* Intercept $\\beta_{0}$ umumnya dapat diinterpretasikan dengan melakukan transformasi terlebih dahulu ke dalam bentuk peluang dengan mengatur nilai peubah prediktor sama dengan 0. Perhitungan ini bisa menggunakan fungsi `predict` dan argumen dari `predict` yaitu `type=\"response\"`.\n* $\\text{p-value} = 0.001 < 0.05 =  \\alpha$ untuk   prediktor `housing [yes]` yang berarti sudah cukup bukti untuk menolak $H_{0}: \\beta_{1}=0$ yang berarti `housing [yes]`  berpengaruh terhadap `subscribed`.\n* 95% CI untuk $(\\beta_{1})$ dapat diinterpretasikan jika sudah kita transformasi ke dalam Odd-Ratio\n\n\nUntuk mendapatkan nilai Odds-Ratio dari koefisien dan intercept kita dapat menerapkan rumus berikut\n\n\n$$\n\\text{Odds-Ratio}(\\beta)=\\exp{(\\beta)}\n$$\n\nsehingga\n\n```{r}\n# intercept\nexp(-1.61)\n# koefisien\nexp(-0.88)\n```\n\n\natau lebih mudah jika kita menggunakan argumen `exponentiate = TRUE` pada fungsi `parameters`. Selain nilai koefisien dan intercept berubah menjadi Odds-Ratio, nilai standard error dan selang kepercayaan (CI) koefisien juga berubah menyesuaikan. Namun, nilai statistik `z` dan `p-value` tidak berubah.\n\n\n```{r}\ntidy_parameters(mod1,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `housing [yes]` $(\\beta_{1})$ adalah $0.42$ berarti nasabah yang memiliki cicilan rumah mempunyai odds 58% $([1-0.42]\\times 100\\%=0.58\\times 100\\%=58\\%)$ **lebih rendah**  dibandingkan dengan nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka.\n* 95% CI dari Odds-Ratio `housing [yes]` berarti 95% yakin bahwa nasabah yang memiliki cicilan rumah menpunyai odds 56% sampai 61% **lebih rendah**  dibandingkan dengan nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka\n* Peluang dari intercept $(\\beta_{1})$ adalah\n\n```{r}\npredict(object = mod1,newdata = data.frame(housing=\"no\"),type = \"response\")\n```\n\ndapat diperhatikan bahwa nilai 0 pada prediktor `housing` adalah saat `housing=\"no\"`. Jadi, peluang nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka adalah $0.1670236$. Secara matematis dapat dihitung sebagai berikut:\n\n$$\n\\begin{eqnarray}\n\\pi(\\textbf{x}) &=& \\frac{\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}{1+\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}} \\\\\n&=& \\frac{\\exp{(-1.61-0.88\\textbf{x})}}{1+\\exp{(-1.61-0.88\\textbf{x})}} \\\\\n\\pi(0)&=& \\frac{\\exp{(-1.61-0.88[0])}}{1+\\exp{(-1.61-0.88[0])}} \\\\\n&=& \\frac{\\exp{(-1.61)}}{1+\\exp{(-1.61)}} \\\\\n&=& \\frac{0.1998876}{1.199888} \\\\\n&=& 0.1665886\n\\end{eqnarray}\n$$\n\n\nSelanjutnya, kita coba mengubah **kategori pembanding** dari `housing`\n\n\n```{r}\nbank_marketing2 <- bank_marketing %>% \n                    mutate(housing=relevel(x=housing,ref=\"yes\"))\n```\n\n\n```{r}\nmod12 <-glm(subscribed==\"yes\"~housing,data=bank_marketing2,family=binomial(link = \"logit\"))\n```\n\n\n```{r}\ntidy_parameters(mod12,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n```{r}\ntidy_parameters(mod12,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `housing [no]` $(\\beta_{1})$ adalah $2.40$ berarti nasabah yang tidak memiliki cicilan rumah mempunyai odds 140% $([2.40-1]\\times 100\\%=1.4\\times 100\\%=140\\%)$ **lebih tinggi**  dibandingkan dengan nasabah yang memiliki cicilan rumah untuk berlangganan deposito berjangka.\n\n\n\n\n\n\n### Regresi Logistik Sederhana dengan variabel prediktor numerik\n\n\n\n\n\n\n```{r}\nmod2 <-glm(subscribed~duration,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\nkemudian untuk mengeluarkan nilai dugaan koefisien, Selang kepercayaan (Confidence Interval) dan p-value dapat menggunakan fungsi `parameters` dari package `parameters`\n\n\n```{r}\ntidy_parameters(mod2,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n* Koefisien dari prediktor `duration` $(\\beta_{1})$ adalah $-0.004$ (negatif) berarti **semakin lama durasi panggilan terakhir maka semakin kecil kemungkinan nasabah untuk berlangganan deposito berjangka**.\n* $\\text{p-value} = 0.001 < 0.05 =  \\alpha$ berarti sudah cukup bukti untuk menolak $H_{0}: \\beta_{1}=0$ yang berarti `duration`  berpengaruh terhadap `subscribed`.\n\n\n```{r}\ntidy_parameters(mod2,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `duration` $(\\beta_{1})$ adalah $1.00$ berarti semakin lama durasi panggilan terakhir maka semakin kecil kemungkinan nasabah untuk berlangganan deposito berjangka.\n\n\n\n\n### Regresi Logistik Berganda dengan variabel prediktor kategorik nominal\n\n\nSecara umum model regresi logistik berganda dapat ditulis:\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{X})}{1-\\pi(\\textbf{X})}\\right]} = \\beta_{0}+\\beta_{1}\\textbf{x}_{1}+\\beta_{2}\\textbf{x}_{2} +\\ldots+\\beta_{p}\\textbf{x}_{p}\n$$\n\n\natau dapat juga ditulis\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{X})}{1-\\pi(\\textbf{X})}\\right]} =\\textbf{X}\\beta\n$$\n\n$$\n\\pi(\\textbf{X}) = \\frac{\\exp{(\\textbf{X}\\beta)}}{1+\\exp{(\\textbf{X}\\beta)}}\n$$\n\n\n\nSama seperti variable prediktor kategorik biner, hal yang harus diperhatikan adalah **kategori pembanding** dari variabel prediktor kategorik nominal. kita bisa memeriksa kategori mana yang menjadi **kategori pembanding** dengan menggunakan fungsi `levels`\n\n\n```{r}\nlevels(bank_marketing$job)\n```\n\nBerdasarkan output diatas **kategori pembanding-nya** adalah `\"admin.\"`. Kita bisa melihat proses transformasi variabel nominal menjadi numerik 0 dan 1 menggunakan fungsi `contrast`\n\n\n```{r}\ncontrasts(bank_marketing$job)\n```\n\n\n\nBerdasarkan output diatas, terlihat bahwa label pada baris menandakan kategori asal, sedangkan label pada kolom berupa nama kolom baru setelah proses transformasi. Disini dapat dilihat dari satu kolom `job`, akan terbentuk sebanyak 11 kolom baru berdasarkan kategori-kategori yang termuat dalam kolom `job`. Dapat diperhatikan juga, bahwa **kategori pembanding** tidak menjadi kolom baru, sehingga kolom baru yang terbentuk dari variabel nominal adalah sebanyak $C-1$ kolom dengan $C$ adalah banyaknya kategori.\n\n\n\n\n```{r}\nmod3 <-glm(subscribed==\"yes\"~job,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n\n```{r}\ntidy_parameters(mod3,ci_method=\"wald\")\n```\n\n\n\n```{r}\ntidy_parameters(mod3,ci_method=\"wald\",exponentiate = TRUE)\n```\n\n\n* Nilai p-value dari 11 kategori ada yang lebih besar dari $\\alpha=0.05$ dan ada yang kecil. Sehingga kategori-kategori untuk nilai p-value lebih besar dari $\\alpha=0.05$ tidak berpengaruh terhadap puebah responnya.\n* Karena ada perbedaan keputusan untuk menolak atau tidak $H_0$, maka kita agak sulit menyimpulkan apakah variabel `job` berpengaruh atau tidak. Oleh karena itu kita bisa menggunakan Analysis of Deviance untuk menyimpulkan apakah `job` berpengaruh atau tidak.\n\n\nBerikut adalah sintaks untuk menjalankan Analysis of Deviance\n\n\n```{r}\nanodev <- car::Anova(mod = mod3,type=3)\n```\n\n\n```{r}\ntidy_parameters(anodev)\n```\n\n\nBerdasarkan hasil $\\text{p-value}=0.0001<0.05=\\alpha$, dapat disimpulkan bahwa variabel `job` berpengaruh terhadap `subscribed` .\n\n\n\n\n### Regresi Logistik Berganda\n\n\n\n```{r}\nmod4 <- glm(subscribed==\"yes\"~.,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n\n\n\n\n\n\n#### Pemeriksaan Multikolinearitas\n\n\nPemeriksaan multikolinearitas bisa menggunakan VIF.\n\n\n```{r}\nplot(multicollinearity(x = mod4))+\n  theme(axis.text.x = element_text(angle = 90))\n```\n\n#### Inferensia Koefisien Regresi Logistik Berganda\n\n\n```{r}\ntidy_parameters(mod4,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,3) ))\n```\n\n\n#### Analysis of Deviance Regresi Logistik Berganda\n\n\n```{r}\nanodev4 <- car::Anova(mod = mod4,type=3)\n```\n\n\n```{r}\ntidy_parameters(anodev4) %>% \n  mutate(across(where(is.numeric),function(x) round(x,3)))\n```\n\n\n\n#### Goodness-of-fits Model\n\n\nGoodness-of-fits Model biasa menggunakan ukuran-ukuran atau metrik-metrik tertentu yang didasarkan dari log-likehood.  Ukuran AICc, BIC, RMSE biasanya digunakan untuk menentukan model terbaik dari beberapa model yang tersedia. Jika hanya satu model saja yang tersedia ukuran ini tidak bisa digunakan. Semakin kecil nila dari AICc, BIC, RMSE maka semakin baik pula modelnya.\n\nSelain itu ada juga ukuran $R^2$ yang bisa digunakan jika model yang tersedia hanya satu. Nilai $R^2$ berkisar antara 0 dan 1. Semakin mendekati 1 nilai $R^2$ semakin baik modelnya.\n\n```{r}\nperformance(model = mod4)\n```\n\n\nKemudian, Goodness-of-fits juga bisa menggunakan uji hipotesis statistik yaitu Likelihood Ratio Test. Secara umum, uji ini membandingkan dua model regresi dan menyimpulkan model mana yang terbaik. Jika kita hanya memliki satu model saja maka model pembandingnya adalah **null-model** atau model tanpa variabel prediktor dan hanya memuat intercept saja. Hipotesis dari Likelihood Ratio Test adalah sebagai berikut:\n\n$$\n\\begin{aligned}\nH_{0}&: \\beta_{1}=\\beta_{2}=\\ldots=\\beta_{29}=0 (\\text{null-model fit [cocok untuk data}]) &\\\\\nH_{1}&: \\exists j, \\beta_j \\neq 0,j=1,2,\\ldots,29 (\\text{model yang diusulkan fit [cocok untuk data}])\n\\end{aligned}\n$$\n\n\nThe likelihood ratio test statistic $G$ didefinisikan sebagai:\n\n$$\nG = -2 \\cdot \\log \\left(\\frac{L_0}{L_1}\\right)\n$$\n\nDi bawah hipotesis nol, $G$ mengikuti distribusi chi-squared dengan derajat kebebasan yang sama dengan perbedaan jumlah parameter yang diduga pada kedua model. $L_0$ adalah likelihood dari data pada model nol dan $L_1$ adalah likelihood dari data pada model yang diusulkan.\n\nJika likelihood ratio test statistic $G$ cukup besar, maka kita menolak hipotesis nol dan memilih hipotesis alternatif, yang menunjukkan bahwa parameter tambahan dalam model yang diusulkan secara signifikan meningkatkan fit (kecocokan untuk data). Berikut adalah sintaksnya\n\n\n\n\n```{r}\ntest_likelihoodratio(mod4)\n```\n\n\n\n\n\n#### Evaluasi performa prediksi\n\n\n\n##### Pembagian Data\n\n\nSalah satu metode yang sering digunakan untuk pembagian data yaitu **holdout sample**. Metode ini membagi amatan pada dateset yang kita miliki menjadi dua bagian yaitu **training data** dan **testing data**. **Training Data** digunakan untuk model \"belajar\" dari data, sedangkan **testing data** digunakan untuk evaluasi performa prediksi model. Secara umum, **training data** harus memiliki amatan yang lebih banyak dibandingkan **testing data**. Pembagian Banyaknya amatan ini bisanya direpresentasikan dalam bentuk proprosi atau persentase seperti 0.8 atau 80%. Proses pembagian ini biasanya didasarkan pada pengambilan sampel acak (**random sampling**). Jika variabel respon yang digunakan berupa kategorik disarankan metode pengambilan sampel acak yang digunakan **stratified random sampling**.\n\n\n\n```{r}\nset.seed(123)\nholdout_split <- initial_split(data = bank_marketing,\n                          prop = 0.8,\n                          strata =\"subscribed\")\n```\n\n\n\n```{r}\ntrain_data <- training(holdout_split)\ntest_data <- testing(holdout_split)\n```\n\n\n```{r}\nbank_marketing %>% \n  mutate(Row=seq(nrow(bank_marketing))) %>% \n  select(subscribed,Row) %>% \n  left_join(y = tidy(holdout_split),by = \"Row\") %>% \n  count(subscribed,Data) %>% \n  group_by(subscribed) %>% \n  mutate(percent=n*100/sum(n),n=NULL) %>% \n  pivot_wider(id_cols = subscribed,names_from = Data,values_from = percent)\n```\n\n\n##### Model Training\n\n\nModel Training dilakukan dengan menggunakan training data yang sudah didapatkan pada proses pembagian data.\n\n\n```{r}\nmod5 <- glm(subscribed==\"yes\"~.,data=train_data,family=binomial(link = \"logit\"))\n```\n\n\n\n##### Evaluasi performa prediksi\n\n\nBerikut adalah sintaks untuk mendapatkan prediksi regresi logistik menggunakan testing data\n\n\n```{r}\npred_reglog0 <- predict(mod5,newdata = test_data,type = \"response\")\nhead(pred_reglog0)\n```\n\nhasil prediksi dari regresi logistik berupa nilai peluang, semakin besar nilai peluangnya maka semakin besar kemungkinan hasil prediksinya adalah kelas positifnya atau dalam hal ini adalah `subscribed==\"yes\"`.\n\n\nKemudian kita akan satukan hasil prediksi ini dengan kolom `subscribed` pada data testing dalam bentuk `data.frame`\n\n\n```{r}\npred_reglog <- data.frame(estimate_prob=pred_reglog0,truth=test_data$subscribed)\npred_reglog\n```\n\nuntuk melakukan evaluasi performa prediksi, maka nilai peluang dari hasil prediksi regresi logistik harus kita konversi menjadi nilai kelas asal yaitu `\"yes\"` dan `\"no\"`. Caranya adalah dengan menentukan suatu **threshold** tertentu pada nilai peluangnya. Sehingga threshold itulah yang menentukan hasil prediksi mana yang menjadi kelas `\"yes\"` atau `\"no\"`. Berikut adalah sintaksnya\n\n\n```{r}\nthreshold = 0.5\npred_reglog <- pred_reglog %>% \n  mutate(estimate=if_else(estimate_prob>threshold,\"yes\",\"no\")) %>% \n  mutate(estimate=factor(estimate,levels=c(\"yes\",\"no\"))) %>% \n  # karena positive class dataset adalah no kita perlu rubah dulu ke yes\n  mutate(truth = factor(truth,levels=c(\"yes\",\"no\")))\n```\n\n\n```{r}\npred_reglog\n```\n\nUmumnya nilai threshold yang digunakan adalah $0.5$, nilai threshold ini bisa kita ganti berdasarkan subjektivitas pengguna ataupun dengan metode-motode optimalisasi threshold. \n\n\n##### Confusion Matrix\n\nHasil prediksi ini biasanya kita evaluasi dengan suatu nilai metrik tertentu. Sebelum ke metrics tersebut, kita akan mengenal **confusion matrix** yang menjadi dasar perhitungan metrik-metrik tersebut. Berikut adalah komponen dari **confusion matrix**\n\n\n![](Confusion Matrix.png)\n\n\n* **TRUE POSITIVE (TP)**: Banyaknya amatan kelas positif yang hasil prediksi modelnya juga kelas positif\n* **TRUE NEGATIVE (TN)**: Banyaknya amatan kelas negatif yang hasil prediksi modelnya juga kelas negatif\n* **FALSE NEGATIVE (FN)**: Banyaknya amatan kelas negatif yang hasil prediksi modelnya kelas positif\n* **FALSE POSITIVE (FP)**: Banyaknya amatan kelas positif yang hasil prediksi modelnya kelas negatif.\n\n\n\nBerikut sintaks mengeluarkan **confusion matrix**.\n\n\n```{r}\nconfussion_matrix <- pred_reglog %>%\n                  conf_mat(truth=truth,estimate=estimate)\n```\n\n\n```{r}\nautoplot(confussion_matrix,type = \"heatmap\")+\n  scale_fill_viridis_c(direction = -1,option = \"inferno\",alpha = 0.6)\n```\n\n\nKemudian berdasarkan TP,TN,FN dan FP dapat dibentuk beberapa metric berikut:\n\nTentu! Dalam bidang statistika, berbagai metrik digunakan untuk mengevaluasi kinerja model klasifikasi berdasarkan matriks kebingungannya. Matriks kebingungan adalah tabel yang menggambarkan kinerja model klasifikasi. Ini menyajikan ringkasan dari prediksi model pada sekelompok data di mana nilai sejati diketahui. Matriks ini memiliki empat entri mungkin: true positives (TP), true negatives (TN), false positives (FP), dan false negatives (FN).\n\nBerikut adalah beberapa metrik umum yang berasal dari matriks kebingungan:\n\n1. **Accuracy (ACC)**:\n   - Accuracy(Akurasi) adalah ukuran banyaknya hasil prediksi model yang benar dari keseluruhan hasil prediksi model.\n   - Formula:\n   \n     $$\n     \\text{Accuracy} = \\frac{{TP + TN}}{{TP + TN + FP + FN}}\n     $$\n\n2. **Precision (juga disebut Positive Predictive Value)**:\n   - Precision (Presisi) adalah proporsi prediksi kelas positif yang benar dari total kelas positif yang diprediksi.\n   - Formula:\n     \n     $$\n     \\text{Precision} = \\frac{{TP}}{{TP + FP}}\n     $$\n\n3. **Recall (juga disebut Sensitivity, Hit Rate, atau True Positive Rate)**:\n   - Recall adalah proporsi kelas positif yang diprediksi benar dari total kelas positif yang sebenarnya.\n   - Formula:\n     \n     $$\n     \\text{Recall} = \\frac{{TP}}{{TP + FN}}\n     $$\n\n4. **F1-Score**:\n   - F1-Score adalah rata-rata harmonik dari presisi dan recall. Metric ini mempertimbangkan keseimbangan antara precision dan recall.\n   - Formula:\n     \n     $$\n     \\text{F}1 = 2 \\times \\frac{{\\text{Precision} \\times \\text{Recall}}}{{\\text{Precision} + \\text{Recall}}}\n     $$\n\n5. **Specificity (juga disebut True Negative Rate))**:\n   - Specificity mengukur proporsi kelas negatif yang diprediksi benar dari total kelas negatif yang sebenarnya.\n   - Formula:\n     \n     $$\n     \\text{Specificity} = \\frac{{TN}}{{TN + FP}}\n     $$\n\n6. **False Positive Rate (FPR)**:\n   - FPR mengukur proporsi FALSE POSITIVE dari total kelas negatif sebenarnya.\n   - Formula:\n   \n     $$\n     FPR = 1 -  \\text{Specificity} = \\frac{{FP}}{{TN + FP}}\n     $$\n\n7. **False Negative Rate (FNR)**:\n   - FNR mengukur proporsi FALSE NEGATIVE dari total kelas positif sebenarnya.\n   - Formula:\n   \n     $$\n     FNR = \\frac{{FN}}{{TP + FN}}\n     $$\n\n8. **Koefisien Korelasi Matthews (MCC)**:\n   - MCC adalah ukuran kualitas klasifikasi biner, mempertimbangkan keempat elemen **confusion matrix**.\n   - Formula:\n     \n     $$\n     MCC = \\frac{{TP \\times TN - FP \\times FN}}{{\\sqrt{{(TP + FP)(TP + FN)(TN + FP)(TN + FN)}}}}\n     $$\n\n9. **Balanced Accuracy**:\n- Balanced Accuracy adalah metrik evaluasi yang berguna ketika dataset memiliki ketimpangan (imbalance) di antara kelas-kelas yang berbeda. Metrik ini memberikan akurasi yang seimbang antara kelas mayoritas dan minoritas.\n   - Formula:\n   \n     $$\n     \\text{Balanced Accuracy} = \\frac{{\\text{Specificity} + \\text{Sensitivity}}}{{2}}\n     $$\n\n\n\n\nmetrik-metrik ini bisa dikeluarkan dengan sintaks berikut:\n\n```{r}\nconfussion_matrix %>% \n  summary()\n```\n\natau kita bisa mengeluarkan salah satu saja seperti berikut\n\n\n```{r}\npred_reglog %>% \n  accuracy(estimate = estimate,truth = truth)\n```\n\natau kita bisa mengeluarkan beberapa\n\n```{r}\nmulti_metric <- metric_set(accuracy,sensitivity,specificity,bal_accuracy,mcc,f_meas)\npred_reglog %>% \n  multi_metric(estimate = estimate,truth = truth)\n```\n\n\n\n\n\n##### Kurva ROC\n\n\nEvaluasi performa prediksi juga bisa didapatkan dengan menggunakan nilai peluang hasil prediksi yang didapatkan dari regresi logistik. Nilai peluang tersebut pada langkah sebelumnya disimpan dalam kolom `estimate_prob`.\n\n\n```{r}\npred_reglog\n```\n\n\nSalah satu alat yang digunakan untuk melakukan evaluasi performa prediksi berdasarkan prediksi peluang adalah kurva ROC. Berikut adalah sintaksnya\n\n\n```{r}\nkurva_roc <- pred_reglog %>% \n              roc_curve(truth = truth,estimate_prob)\nkurva_roc \n```\n\n\n\n```{r}\nautoplot(kurva_roc)\n```\n\n\nBerdasarkan dua output diatas, kita bisa melihat bahwa kurva ROC dibentuk berdasarkan metrik sensitivity dan specificity yang dihitung dari berbagai macam kemungkinan threshold. Oleh karena itu, kurva ROC ini juga sering digunakan untuk mendapatkan threshold optimal berdasarkan sensitivity dan specificity. \n\nKurva ROC ini biasanya digunakan untuk menentukan model dengan performa prediksi terbaik. Namun, pada ilustrasi ini kita hanya menggunakan satu model sehingga kurva ROC ini kurang bisa digunakan. Tetapi, terdapat metrik yang berbasiskan kurva roc yang bisa digunakan tanpa membandingkan dengan model lain yaitu **AREA Under Curve (AUC)**. \n\n```{r}\npred_reglog %>% \n  roc_auc(truth = truth,estimate_prob)\n```\n\n\n##### Threshold Optimal\n\n\nSelanjutnya kita akan mencoba mendapatkan threshold optimal berdasarkan sensitivity dan specificity menggunakan **Youden's J statistic** yang didefinisikan sebagai berikut\n\n$$\n\\text{Youden's J statistic} = \\text{sensitivity} + \\text{specificity}-1\n$$\n\nSemakin mendekati 1 nilainya maka semakin baik thresholdnya dan semakin nilainya mendekati 0 semakin buruk thresholdnya. Jika kita terapkan pada sintaks adalah sebagai berikut. \n\n\n```{r}\nkurva_roc %>% \n  mutate(youden_index=sensitivity+specificity-1)\n```\n\nkemudian karena kita mencari **Youden's J statistic** yang mendekati satu berarti sama saja kita mencari nilai threshold yang **Youden's J statistic** paling maksimum. Kita bisa mendapatkan nilai maksimum ini dengan bantuan fungsi `slice_max`\n\n\n```{r}\noptimal_thresh <- kurva_roc %>% \n  mutate(youden_index=sensitivity+specificity-1) %>% \n  slice_max(order_by = youden_index)\noptimal_thresh\n```\n\nKemudian hasil prediksi dengan threshold optimal bisa didapatkan dengan sintaks berikut\n\n\n```{r}\npred_reglog2 <- data.frame(estimate_prob=pred_reglog0,truth=test_data$subscribed)\nthreshold2 = optimal_thresh %>% pull(.threshold)\npred_reglog2 <- pred_reglog2 %>% \n  mutate(estimate=if_else(estimate_prob>threshold2,\"yes\",\"no\")) %>% \n  mutate(estimate=factor(estimate,levels=c(\"yes\",\"no\"))) %>% \n  # karena positive class dataset adalah no kita perlu rubah dulu ke yes\n  mutate(truth = factor(truth,levels=c(\"yes\",\"no\")))\npred_reglog2\n```\n\nKemudian jika kita bandingkan antara threshold 0.5 dengan threshold optimal pada beberapa metric maka hasilnya adalah sebagai berikut\n\n\n```{r}\nres_metric2 <- pred_reglog2 %>% \n  multi_metric(truth = truth,estimate = estimate) %>% \n  mutate(threshold=threshold2) %>% \n  relocate(threshold,.after = .metric)\n\nres_metric <- pred_reglog %>% \n  multi_metric(truth = truth,estimate = estimate) %>% \n  mutate(threshold=threshold) %>% \n  relocate(threshold,.after = .metric)\n```\n\n\n\n```{r}\nres_metric2 %>% \n  bind_rows(res_metric) %>% \n  select(-.estimator) %>% \n  pivot_wider(id_cols = .metric,names_from = threshold,\n              names_prefix =\"thres=\", \n              values_from = .estimate)\n```\n\n\n### Prediksi Data Baru\n\n\nuntuk mengilustrasikan prediksi pada data baru, kita akan membuat suatu data baru \"buatan\" dengan mengambil sampel acak dari data `bank_marketing`. Data baru bisanya tidak memuat variabel response sehingga kita akan hilangkan kolom `subscribed`.\n\n\n```{r}\nset.seed(123)\ndata_baru <- bank_marketing %>% \n              slice_sample(n = 10) %>% \n              select(-subscribed)\ndata_baru\n```\n\n\n\n```{r}\npred_data_baru <- predict(mod4,newdata = data_baru,type = \"response\")\n```\n\n```{r}\nthreshold2\npred_data_baru_df <- data.frame(estimate=pred_data_baru) %>% \n                      mutate(estimate=if_else(estimate>threshold2,\"yes\",\"no\")) %>% \n                      mutate(estimate=factor(estimate,levels=c(\"no\",\"yes\")))\npred_data_baru_df\n```\n\n\n","srcMarkdownNoYaml":"\n\n\n\n## Package\n\n\n```{r eval=FALSE}\ninstall.packages(\"see\")\n```\n\n\n\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(broom.helpers)\nlibrary(skimr)\nlibrary(performance)\nlibrary(rsample)\nlibrary(yardstick)\nlibrary(DataExplorer)\n```\n\nSebenarnya Anda tidak perlu untuk load keseluruhan pakcage, Anda bisa menggunakan syntax `namapackage::fungsi` untuk menggunakan suatu fungsi dari suatu package di R, selama package tersebut sudah Anda Install.\n\n## Data\n\nData ini terkait dengan promosi marketing langsung dari suatu institusi perbankan Portugal.  Promosi marketing tersebut didasarkan pada panggilan telepon. Sering kali, diperlukan lebih dari satu kali kontak ke klien yang sama, untuk memastikan apakah produk (deposito berjangka bank) akan (atau tidak) berlangganan. \n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nread_delim(delim = \";\",file =\n  'No;Variabel;Keterangan\n   1;age;umur nasabah(numeric)\n   2;job;jenis pekerjaan nasabah(categorical:\"admin.\",\"unknown\",\"unemployed\",\"management\",\"housemaid\",\"entrepreneur\",\"student\",\"blue-collar\",\"self-employed\",\"retired\",\"technician\",\"services\") \n   3;marital;status perkawinan nasabah (categorical: \"married\",\"divorced\",\"single\")\n   4;education;tingkat pendidikan(categorical: \"unknown\",\"secondary\",\"primary\",\"tertiary\")\n   5;default;apakah nasabah memiliki kredit yang macet? (binary: \"yes\",\"no\")\n   6;balance;saldo tahunan rata-rata dalam euros (numeric) \n   7;housing;apakah nasabah memiliki cicilan rumah? (binary: \"yes\",\"no\")\n   8;loan;apakah nasabah memiliki pinjaman pribadi? (binary: \"yes\",\"no\")\n   9;contact;perangkat telekomunikasi (categorical: \"unknown\",\"telephone\",\"cellular\") \n   10;duration;durasi panggilan terakhir, dalam detik (numeric)\n  11;pdays; banyaknya hari yang telah berlalu setelah klien terakhir kali dihubungi dari campaign sebelumnya (angka, -1 berarti klien tidak dihubungi sebelumnya)\n  12;previous;banyaknya komunikasi yang dilakukan sebelum campaign ini(numeric)\n  13;poutcome;hasil dari promosi campaign sebelumnya (categorical: \"unknown\",\"other\",\"failure\",\"success\")\n  14;subscribed;response variable (desired target),apakah nasabah telah berlangganan deposito berjangka? (binary: \"yes\",\"no\")') %>% \n  gt::gt()\n```\n\n\n[Download Data](https://drive.google.com/file/d/11e5IwdRsIepcUwS6OQQAdYb6_6mJsKSD/view?usp=drive_link)\n\n  \n## Import Data\n\n```{r}\nbank_marketing <- read_csv(\"bank_marketing.csv\")\n```\n\n```{r}\nglimpse(bank_marketing)\n```\n\nkarena fungsi `glm` untuk membutuhkan semua variabel (kolom) kategorik (biner atau nominal) dalam tipe data `factor` maka kita akan konversi terlebih dahulu.\n\n\n```{r}\nbank_marketing <- bank_marketing %>% \n              mutate(across(where(is.character),.fns =as.factor))\nglimpse(bank_marketing)\n```\n\n\n\n\n## Eksplorasi Data\n\n### Menggunakan Ringkasan Statistik\n\n\n```{r}\nskim_without_charts(data = bank_marketing)\n```\n\n### Menggunakan Visualisasi\n\n\n### Eksplorasi Umum\n\n```{r}\nplot_intro(data = bank_marketing,\n           ggtheme = theme_classic(),\n           theme_config = list(axis.line=element_blank(),\n                               axis.ticks=element_blank(),\n                               axis.text.x=element_blank(),\n                               axis.title=element_blank()\n                               )  \n           )\n```\n\n\n#### Eksplorasi Korelasi\n\n##### Korelasi variabel prediktor numerik dengan variabel response\n\n\n```{r}\nplot_boxplot(data = bank_marketing,by = \"subscribed\",\n             geom_boxplot_args = list(fill=\"#03A9F4\"),\n             ggtheme = theme_classic())\n```\n\n\n##### Korelasi variabel prediktor kategorik dengan variabel response\n\n\n```{r}\nplot_bar(data = bank_marketing,by = \"subscribed\",\n             ggtheme = theme_classic(),\n         ncol = 2)\n```\n\n## Pemodelan Regresi Logistik\n\n\n\n### Regresi Logistik Sederhana dengan variabel prediktor biner\n\n\nSecara umum model regresi logistik sederhana dapat ditulis:\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{x})}{1-\\pi(\\textbf{x})}\\right]} = \\beta_{0}+\\beta_{1}\\textbf{x}\n$$\n\ndimana:\n\n* $\\pi(\\textbf{x})=P(Y=1|\\pi(\\textbf{x}))$ dan $1-\\pi(\\textbf{x})=1-P(Y=1|\\pi(\\textbf{x}))=P(Y=0|\\pi(\\textbf{x}))$\n\n\natau dapat juga ditulis\n\n\n$$\n\\pi(\\textbf{x}) = \\frac{\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}{1+\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}\n$$\n\n\nPemodelan Regresi Logistik Sederhana dengan variabel prediktor biner perlu memperhatikan **reference category** atau **kategori pembanding** dari variabel prediktor biner tersebut. **Kategori pembanding** akan dikodekan dengan 0 dan kategori lainnya akan dikodekan dengan 1. Proses pengkodean ini sebenarnya adalah proses transformasi variabel biner menjadi variabel numerik. Variable hasil transformasi ini sering disebut dengan **variabel dummy** atau variabel yang amtan-amatannya hanya bernilai 1 atau 0.\n\n\nDalam R, **Kategori pembanding** ini biasanya merupakan kategori pertama yang ditunjukkan dari output fungsi `levels`. Berikut ilustrasinya\n\n```{r}\nlevels(bank_marketing$housing)\n```\n\nBerdasarkan output diatas, berarti **Kategori pembanding-nya** adalah `\"no\"` karena berada di urutan pertama. kita bisa merubah **Kategori pembanding** dengan fungsi `relevel` dan mengisi argumen `ref` dengan kategori yang akan dijadikan sebagai **kategori pembanding**. Berikut ilustrasinya\n\n\n```{r}\ncoba <- relevel(x = bank_marketing$housing,ref = \"yes\")\nlevels(coba)\n```\n\nKita bisa membandingkan proses transformasi variabel biner menjadi numerik 0 dan 1 menggunakan fungsi `contrast`\n\n```{r}\ncontrasts(bank_marketing$housing) %>% as.data.frame()\ncontrasts(coba) %>% as.data.frame()\n```\n\n\n\n\n\n\nfungsi `glm` dapat digunakan untuk menjalan regresi logistik.\n\n\n```{r}\nmod1 <-glm(subscribed==\"yes\"~housing,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n* sintaks `subscribed==\"yes\"` berarti kita menenetapkan kelas positifnya adalah `yes` atau $P(Y=1|\\pi(\\textbf{x}))$ sedangkan kelas negatifnya adalah `no`  atau $P(Y=0|\\pi(\\textbf{x}))$\n* jika kita tidak mendefinisikan dengan sintaks `subscribed==\"yes\"` maka secara default yang akan menjadi kelas positif adalah kategori pertama yang ditunjukkan dari output fungsi `levels`. Dalam kasus variabel respon `subscribed`, secara default yang menjadi kelas positif adalah `no`. Berikut cara mengecek kategori pertama dari `levels`.\n\n\n```{r}\nlevels(bank_marketing$subscribed)\n```\n\n* sintaks `~housing` menandakan bahwa `housing` adalah variabel prediktor.\n* sintaks `family(link = \"logit\")` digunakan untuk menandakan kita menggunakan regresi logistik.\n\n\n\nkemudian untuk mengeluarkan nilai dugaan koefisien, Selang kepercayaan (Confidence Interval) dan p-value dapat menggunakan fungsi `parameters` dari package `parameters`\n\n\n```{r}\ntidy_parameters(mod1,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n* Koefisien dari prediktor `housing [yes]` $(\\beta_{1})$ adalah $-0.88$ (negatif) berarti **saat nasabah memiliki cicilan rumah maka kemungkinan nasabah tidak akan berlangganan deposito berjangka**.\n* Intercept $\\beta_{0}$ umumnya dapat diinterpretasikan dengan melakukan transformasi terlebih dahulu ke dalam bentuk peluang dengan mengatur nilai peubah prediktor sama dengan 0. Perhitungan ini bisa menggunakan fungsi `predict` dan argumen dari `predict` yaitu `type=\"response\"`.\n* $\\text{p-value} = 0.001 < 0.05 =  \\alpha$ untuk   prediktor `housing [yes]` yang berarti sudah cukup bukti untuk menolak $H_{0}: \\beta_{1}=0$ yang berarti `housing [yes]`  berpengaruh terhadap `subscribed`.\n* 95% CI untuk $(\\beta_{1})$ dapat diinterpretasikan jika sudah kita transformasi ke dalam Odd-Ratio\n\n\nUntuk mendapatkan nilai Odds-Ratio dari koefisien dan intercept kita dapat menerapkan rumus berikut\n\n\n$$\n\\text{Odds-Ratio}(\\beta)=\\exp{(\\beta)}\n$$\n\nsehingga\n\n```{r}\n# intercept\nexp(-1.61)\n# koefisien\nexp(-0.88)\n```\n\n\natau lebih mudah jika kita menggunakan argumen `exponentiate = TRUE` pada fungsi `parameters`. Selain nilai koefisien dan intercept berubah menjadi Odds-Ratio, nilai standard error dan selang kepercayaan (CI) koefisien juga berubah menyesuaikan. Namun, nilai statistik `z` dan `p-value` tidak berubah.\n\n\n```{r}\ntidy_parameters(mod1,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `housing [yes]` $(\\beta_{1})$ adalah $0.42$ berarti nasabah yang memiliki cicilan rumah mempunyai odds 58% $([1-0.42]\\times 100\\%=0.58\\times 100\\%=58\\%)$ **lebih rendah**  dibandingkan dengan nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka.\n* 95% CI dari Odds-Ratio `housing [yes]` berarti 95% yakin bahwa nasabah yang memiliki cicilan rumah menpunyai odds 56% sampai 61% **lebih rendah**  dibandingkan dengan nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka\n* Peluang dari intercept $(\\beta_{1})$ adalah\n\n```{r}\npredict(object = mod1,newdata = data.frame(housing=\"no\"),type = \"response\")\n```\n\ndapat diperhatikan bahwa nilai 0 pada prediktor `housing` adalah saat `housing=\"no\"`. Jadi, peluang nasabah yang tidak memiliki cicilan rumah untuk berlangganan deposito berjangka adalah $0.1670236$. Secara matematis dapat dihitung sebagai berikut:\n\n$$\n\\begin{eqnarray}\n\\pi(\\textbf{x}) &=& \\frac{\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}}{1+\\exp{(\\beta_{0}+\\beta_{1}\\textbf{x})}} \\\\\n&=& \\frac{\\exp{(-1.61-0.88\\textbf{x})}}{1+\\exp{(-1.61-0.88\\textbf{x})}} \\\\\n\\pi(0)&=& \\frac{\\exp{(-1.61-0.88[0])}}{1+\\exp{(-1.61-0.88[0])}} \\\\\n&=& \\frac{\\exp{(-1.61)}}{1+\\exp{(-1.61)}} \\\\\n&=& \\frac{0.1998876}{1.199888} \\\\\n&=& 0.1665886\n\\end{eqnarray}\n$$\n\n\nSelanjutnya, kita coba mengubah **kategori pembanding** dari `housing`\n\n\n```{r}\nbank_marketing2 <- bank_marketing %>% \n                    mutate(housing=relevel(x=housing,ref=\"yes\"))\n```\n\n\n```{r}\nmod12 <-glm(subscribed==\"yes\"~housing,data=bank_marketing2,family=binomial(link = \"logit\"))\n```\n\n\n```{r}\ntidy_parameters(mod12,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n```{r}\ntidy_parameters(mod12,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `housing [no]` $(\\beta_{1})$ adalah $2.40$ berarti nasabah yang tidak memiliki cicilan rumah mempunyai odds 140% $([2.40-1]\\times 100\\%=1.4\\times 100\\%=140\\%)$ **lebih tinggi**  dibandingkan dengan nasabah yang memiliki cicilan rumah untuk berlangganan deposito berjangka.\n\n\n\n\n\n\n### Regresi Logistik Sederhana dengan variabel prediktor numerik\n\n\n\n\n\n\n```{r}\nmod2 <-glm(subscribed~duration,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\nkemudian untuk mengeluarkan nilai dugaan koefisien, Selang kepercayaan (Confidence Interval) dan p-value dapat menggunakan fungsi `parameters` dari package `parameters`\n\n\n```{r}\ntidy_parameters(mod2,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\")\n```\n\n\n* Koefisien dari prediktor `duration` $(\\beta_{1})$ adalah $-0.004$ (negatif) berarti **semakin lama durasi panggilan terakhir maka semakin kecil kemungkinan nasabah untuk berlangganan deposito berjangka**.\n* $\\text{p-value} = 0.001 < 0.05 =  \\alpha$ berarti sudah cukup bukti untuk menolak $H_{0}: \\beta_{1}=0$ yang berarti `duration`  berpengaruh terhadap `subscribed`.\n\n\n```{r}\ntidy_parameters(mod2,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,2) ))\n```\n\n\n* Odds-Ratio dari prediktor `duration` $(\\beta_{1})$ adalah $1.00$ berarti semakin lama durasi panggilan terakhir maka semakin kecil kemungkinan nasabah untuk berlangganan deposito berjangka.\n\n\n\n\n### Regresi Logistik Berganda dengan variabel prediktor kategorik nominal\n\n\nSecara umum model regresi logistik berganda dapat ditulis:\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{X})}{1-\\pi(\\textbf{X})}\\right]} = \\beta_{0}+\\beta_{1}\\textbf{x}_{1}+\\beta_{2}\\textbf{x}_{2} +\\ldots+\\beta_{p}\\textbf{x}_{p}\n$$\n\n\natau dapat juga ditulis\n\n\n$$\n\\mathbf{\\mu}=E(\\textbf{y})=\\log{\\left[\\frac{\\pi(\\textbf{X})}{1-\\pi(\\textbf{X})}\\right]} =\\textbf{X}\\beta\n$$\n\n$$\n\\pi(\\textbf{X}) = \\frac{\\exp{(\\textbf{X}\\beta)}}{1+\\exp{(\\textbf{X}\\beta)}}\n$$\n\n\n\nSama seperti variable prediktor kategorik biner, hal yang harus diperhatikan adalah **kategori pembanding** dari variabel prediktor kategorik nominal. kita bisa memeriksa kategori mana yang menjadi **kategori pembanding** dengan menggunakan fungsi `levels`\n\n\n```{r}\nlevels(bank_marketing$job)\n```\n\nBerdasarkan output diatas **kategori pembanding-nya** adalah `\"admin.\"`. Kita bisa melihat proses transformasi variabel nominal menjadi numerik 0 dan 1 menggunakan fungsi `contrast`\n\n\n```{r}\ncontrasts(bank_marketing$job)\n```\n\n\n\nBerdasarkan output diatas, terlihat bahwa label pada baris menandakan kategori asal, sedangkan label pada kolom berupa nama kolom baru setelah proses transformasi. Disini dapat dilihat dari satu kolom `job`, akan terbentuk sebanyak 11 kolom baru berdasarkan kategori-kategori yang termuat dalam kolom `job`. Dapat diperhatikan juga, bahwa **kategori pembanding** tidak menjadi kolom baru, sehingga kolom baru yang terbentuk dari variabel nominal adalah sebanyak $C-1$ kolom dengan $C$ adalah banyaknya kategori.\n\n\n\n\n```{r}\nmod3 <-glm(subscribed==\"yes\"~job,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n\n```{r}\ntidy_parameters(mod3,ci_method=\"wald\")\n```\n\n\n\n```{r}\ntidy_parameters(mod3,ci_method=\"wald\",exponentiate = TRUE)\n```\n\n\n* Nilai p-value dari 11 kategori ada yang lebih besar dari $\\alpha=0.05$ dan ada yang kecil. Sehingga kategori-kategori untuk nilai p-value lebih besar dari $\\alpha=0.05$ tidak berpengaruh terhadap puebah responnya.\n* Karena ada perbedaan keputusan untuk menolak atau tidak $H_0$, maka kita agak sulit menyimpulkan apakah variabel `job` berpengaruh atau tidak. Oleh karena itu kita bisa menggunakan Analysis of Deviance untuk menyimpulkan apakah `job` berpengaruh atau tidak.\n\n\nBerikut adalah sintaks untuk menjalankan Analysis of Deviance\n\n\n```{r}\nanodev <- car::Anova(mod = mod3,type=3)\n```\n\n\n```{r}\ntidy_parameters(anodev)\n```\n\n\nBerdasarkan hasil $\\text{p-value}=0.0001<0.05=\\alpha$, dapat disimpulkan bahwa variabel `job` berpengaruh terhadap `subscribed` .\n\n\n\n\n### Regresi Logistik Berganda\n\n\n\n```{r}\nmod4 <- glm(subscribed==\"yes\"~.,data=bank_marketing,family=binomial(link = \"logit\"))\n```\n\n\n\n\n\n\n\n\n#### Pemeriksaan Multikolinearitas\n\n\nPemeriksaan multikolinearitas bisa menggunakan VIF.\n\n\n```{r}\nplot(multicollinearity(x = mod4))+\n  theme(axis.text.x = element_text(angle = 90))\n```\n\n#### Inferensia Koefisien Regresi Logistik Berganda\n\n\n```{r}\ntidy_parameters(mod4,conf.int = TRUE,conf.level = 0.95,ci_method=\"wald\",exponentiate = TRUE) %>% \n  mutate(across(where(is.numeric),function(x) round(x,3) ))\n```\n\n\n#### Analysis of Deviance Regresi Logistik Berganda\n\n\n```{r}\nanodev4 <- car::Anova(mod = mod4,type=3)\n```\n\n\n```{r}\ntidy_parameters(anodev4) %>% \n  mutate(across(where(is.numeric),function(x) round(x,3)))\n```\n\n\n\n#### Goodness-of-fits Model\n\n\nGoodness-of-fits Model biasa menggunakan ukuran-ukuran atau metrik-metrik tertentu yang didasarkan dari log-likehood.  Ukuran AICc, BIC, RMSE biasanya digunakan untuk menentukan model terbaik dari beberapa model yang tersedia. Jika hanya satu model saja yang tersedia ukuran ini tidak bisa digunakan. Semakin kecil nila dari AICc, BIC, RMSE maka semakin baik pula modelnya.\n\nSelain itu ada juga ukuran $R^2$ yang bisa digunakan jika model yang tersedia hanya satu. Nilai $R^2$ berkisar antara 0 dan 1. Semakin mendekati 1 nilai $R^2$ semakin baik modelnya.\n\n```{r}\nperformance(model = mod4)\n```\n\n\nKemudian, Goodness-of-fits juga bisa menggunakan uji hipotesis statistik yaitu Likelihood Ratio Test. Secara umum, uji ini membandingkan dua model regresi dan menyimpulkan model mana yang terbaik. Jika kita hanya memliki satu model saja maka model pembandingnya adalah **null-model** atau model tanpa variabel prediktor dan hanya memuat intercept saja. Hipotesis dari Likelihood Ratio Test adalah sebagai berikut:\n\n$$\n\\begin{aligned}\nH_{0}&: \\beta_{1}=\\beta_{2}=\\ldots=\\beta_{29}=0 (\\text{null-model fit [cocok untuk data}]) &\\\\\nH_{1}&: \\exists j, \\beta_j \\neq 0,j=1,2,\\ldots,29 (\\text{model yang diusulkan fit [cocok untuk data}])\n\\end{aligned}\n$$\n\n\nThe likelihood ratio test statistic $G$ didefinisikan sebagai:\n\n$$\nG = -2 \\cdot \\log \\left(\\frac{L_0}{L_1}\\right)\n$$\n\nDi bawah hipotesis nol, $G$ mengikuti distribusi chi-squared dengan derajat kebebasan yang sama dengan perbedaan jumlah parameter yang diduga pada kedua model. $L_0$ adalah likelihood dari data pada model nol dan $L_1$ adalah likelihood dari data pada model yang diusulkan.\n\nJika likelihood ratio test statistic $G$ cukup besar, maka kita menolak hipotesis nol dan memilih hipotesis alternatif, yang menunjukkan bahwa parameter tambahan dalam model yang diusulkan secara signifikan meningkatkan fit (kecocokan untuk data). Berikut adalah sintaksnya\n\n\n\n\n```{r}\ntest_likelihoodratio(mod4)\n```\n\n\n\n\n\n#### Evaluasi performa prediksi\n\n\n\n##### Pembagian Data\n\n\nSalah satu metode yang sering digunakan untuk pembagian data yaitu **holdout sample**. Metode ini membagi amatan pada dateset yang kita miliki menjadi dua bagian yaitu **training data** dan **testing data**. **Training Data** digunakan untuk model \"belajar\" dari data, sedangkan **testing data** digunakan untuk evaluasi performa prediksi model. Secara umum, **training data** harus memiliki amatan yang lebih banyak dibandingkan **testing data**. Pembagian Banyaknya amatan ini bisanya direpresentasikan dalam bentuk proprosi atau persentase seperti 0.8 atau 80%. Proses pembagian ini biasanya didasarkan pada pengambilan sampel acak (**random sampling**). Jika variabel respon yang digunakan berupa kategorik disarankan metode pengambilan sampel acak yang digunakan **stratified random sampling**.\n\n\n\n```{r}\nset.seed(123)\nholdout_split <- initial_split(data = bank_marketing,\n                          prop = 0.8,\n                          strata =\"subscribed\")\n```\n\n\n\n```{r}\ntrain_data <- training(holdout_split)\ntest_data <- testing(holdout_split)\n```\n\n\n```{r}\nbank_marketing %>% \n  mutate(Row=seq(nrow(bank_marketing))) %>% \n  select(subscribed,Row) %>% \n  left_join(y = tidy(holdout_split),by = \"Row\") %>% \n  count(subscribed,Data) %>% \n  group_by(subscribed) %>% \n  mutate(percent=n*100/sum(n),n=NULL) %>% \n  pivot_wider(id_cols = subscribed,names_from = Data,values_from = percent)\n```\n\n\n##### Model Training\n\n\nModel Training dilakukan dengan menggunakan training data yang sudah didapatkan pada proses pembagian data.\n\n\n```{r}\nmod5 <- glm(subscribed==\"yes\"~.,data=train_data,family=binomial(link = \"logit\"))\n```\n\n\n\n##### Evaluasi performa prediksi\n\n\nBerikut adalah sintaks untuk mendapatkan prediksi regresi logistik menggunakan testing data\n\n\n```{r}\npred_reglog0 <- predict(mod5,newdata = test_data,type = \"response\")\nhead(pred_reglog0)\n```\n\nhasil prediksi dari regresi logistik berupa nilai peluang, semakin besar nilai peluangnya maka semakin besar kemungkinan hasil prediksinya adalah kelas positifnya atau dalam hal ini adalah `subscribed==\"yes\"`.\n\n\nKemudian kita akan satukan hasil prediksi ini dengan kolom `subscribed` pada data testing dalam bentuk `data.frame`\n\n\n```{r}\npred_reglog <- data.frame(estimate_prob=pred_reglog0,truth=test_data$subscribed)\npred_reglog\n```\n\nuntuk melakukan evaluasi performa prediksi, maka nilai peluang dari hasil prediksi regresi logistik harus kita konversi menjadi nilai kelas asal yaitu `\"yes\"` dan `\"no\"`. Caranya adalah dengan menentukan suatu **threshold** tertentu pada nilai peluangnya. Sehingga threshold itulah yang menentukan hasil prediksi mana yang menjadi kelas `\"yes\"` atau `\"no\"`. Berikut adalah sintaksnya\n\n\n```{r}\nthreshold = 0.5\npred_reglog <- pred_reglog %>% \n  mutate(estimate=if_else(estimate_prob>threshold,\"yes\",\"no\")) %>% \n  mutate(estimate=factor(estimate,levels=c(\"yes\",\"no\"))) %>% \n  # karena positive class dataset adalah no kita perlu rubah dulu ke yes\n  mutate(truth = factor(truth,levels=c(\"yes\",\"no\")))\n```\n\n\n```{r}\npred_reglog\n```\n\nUmumnya nilai threshold yang digunakan adalah $0.5$, nilai threshold ini bisa kita ganti berdasarkan subjektivitas pengguna ataupun dengan metode-motode optimalisasi threshold. \n\n\n##### Confusion Matrix\n\nHasil prediksi ini biasanya kita evaluasi dengan suatu nilai metrik tertentu. Sebelum ke metrics tersebut, kita akan mengenal **confusion matrix** yang menjadi dasar perhitungan metrik-metrik tersebut. Berikut adalah komponen dari **confusion matrix**\n\n\n![](Confusion Matrix.png)\n\n\n* **TRUE POSITIVE (TP)**: Banyaknya amatan kelas positif yang hasil prediksi modelnya juga kelas positif\n* **TRUE NEGATIVE (TN)**: Banyaknya amatan kelas negatif yang hasil prediksi modelnya juga kelas negatif\n* **FALSE NEGATIVE (FN)**: Banyaknya amatan kelas negatif yang hasil prediksi modelnya kelas positif\n* **FALSE POSITIVE (FP)**: Banyaknya amatan kelas positif yang hasil prediksi modelnya kelas negatif.\n\n\n\nBerikut sintaks mengeluarkan **confusion matrix**.\n\n\n```{r}\nconfussion_matrix <- pred_reglog %>%\n                  conf_mat(truth=truth,estimate=estimate)\n```\n\n\n```{r}\nautoplot(confussion_matrix,type = \"heatmap\")+\n  scale_fill_viridis_c(direction = -1,option = \"inferno\",alpha = 0.6)\n```\n\n\nKemudian berdasarkan TP,TN,FN dan FP dapat dibentuk beberapa metric berikut:\n\nTentu! Dalam bidang statistika, berbagai metrik digunakan untuk mengevaluasi kinerja model klasifikasi berdasarkan matriks kebingungannya. Matriks kebingungan adalah tabel yang menggambarkan kinerja model klasifikasi. Ini menyajikan ringkasan dari prediksi model pada sekelompok data di mana nilai sejati diketahui. Matriks ini memiliki empat entri mungkin: true positives (TP), true negatives (TN), false positives (FP), dan false negatives (FN).\n\nBerikut adalah beberapa metrik umum yang berasal dari matriks kebingungan:\n\n1. **Accuracy (ACC)**:\n   - Accuracy(Akurasi) adalah ukuran banyaknya hasil prediksi model yang benar dari keseluruhan hasil prediksi model.\n   - Formula:\n   \n     $$\n     \\text{Accuracy} = \\frac{{TP + TN}}{{TP + TN + FP + FN}}\n     $$\n\n2. **Precision (juga disebut Positive Predictive Value)**:\n   - Precision (Presisi) adalah proporsi prediksi kelas positif yang benar dari total kelas positif yang diprediksi.\n   - Formula:\n     \n     $$\n     \\text{Precision} = \\frac{{TP}}{{TP + FP}}\n     $$\n\n3. **Recall (juga disebut Sensitivity, Hit Rate, atau True Positive Rate)**:\n   - Recall adalah proporsi kelas positif yang diprediksi benar dari total kelas positif yang sebenarnya.\n   - Formula:\n     \n     $$\n     \\text{Recall} = \\frac{{TP}}{{TP + FN}}\n     $$\n\n4. **F1-Score**:\n   - F1-Score adalah rata-rata harmonik dari presisi dan recall. Metric ini mempertimbangkan keseimbangan antara precision dan recall.\n   - Formula:\n     \n     $$\n     \\text{F}1 = 2 \\times \\frac{{\\text{Precision} \\times \\text{Recall}}}{{\\text{Precision} + \\text{Recall}}}\n     $$\n\n5. **Specificity (juga disebut True Negative Rate))**:\n   - Specificity mengukur proporsi kelas negatif yang diprediksi benar dari total kelas negatif yang sebenarnya.\n   - Formula:\n     \n     $$\n     \\text{Specificity} = \\frac{{TN}}{{TN + FP}}\n     $$\n\n6. **False Positive Rate (FPR)**:\n   - FPR mengukur proporsi FALSE POSITIVE dari total kelas negatif sebenarnya.\n   - Formula:\n   \n     $$\n     FPR = 1 -  \\text{Specificity} = \\frac{{FP}}{{TN + FP}}\n     $$\n\n7. **False Negative Rate (FNR)**:\n   - FNR mengukur proporsi FALSE NEGATIVE dari total kelas positif sebenarnya.\n   - Formula:\n   \n     $$\n     FNR = \\frac{{FN}}{{TP + FN}}\n     $$\n\n8. **Koefisien Korelasi Matthews (MCC)**:\n   - MCC adalah ukuran kualitas klasifikasi biner, mempertimbangkan keempat elemen **confusion matrix**.\n   - Formula:\n     \n     $$\n     MCC = \\frac{{TP \\times TN - FP \\times FN}}{{\\sqrt{{(TP + FP)(TP + FN)(TN + FP)(TN + FN)}}}}\n     $$\n\n9. **Balanced Accuracy**:\n- Balanced Accuracy adalah metrik evaluasi yang berguna ketika dataset memiliki ketimpangan (imbalance) di antara kelas-kelas yang berbeda. Metrik ini memberikan akurasi yang seimbang antara kelas mayoritas dan minoritas.\n   - Formula:\n   \n     $$\n     \\text{Balanced Accuracy} = \\frac{{\\text{Specificity} + \\text{Sensitivity}}}{{2}}\n     $$\n\n\n\n\nmetrik-metrik ini bisa dikeluarkan dengan sintaks berikut:\n\n```{r}\nconfussion_matrix %>% \n  summary()\n```\n\natau kita bisa mengeluarkan salah satu saja seperti berikut\n\n\n```{r}\npred_reglog %>% \n  accuracy(estimate = estimate,truth = truth)\n```\n\natau kita bisa mengeluarkan beberapa\n\n```{r}\nmulti_metric <- metric_set(accuracy,sensitivity,specificity,bal_accuracy,mcc,f_meas)\npred_reglog %>% \n  multi_metric(estimate = estimate,truth = truth)\n```\n\n\n\n\n\n##### Kurva ROC\n\n\nEvaluasi performa prediksi juga bisa didapatkan dengan menggunakan nilai peluang hasil prediksi yang didapatkan dari regresi logistik. Nilai peluang tersebut pada langkah sebelumnya disimpan dalam kolom `estimate_prob`.\n\n\n```{r}\npred_reglog\n```\n\n\nSalah satu alat yang digunakan untuk melakukan evaluasi performa prediksi berdasarkan prediksi peluang adalah kurva ROC. Berikut adalah sintaksnya\n\n\n```{r}\nkurva_roc <- pred_reglog %>% \n              roc_curve(truth = truth,estimate_prob)\nkurva_roc \n```\n\n\n\n```{r}\nautoplot(kurva_roc)\n```\n\n\nBerdasarkan dua output diatas, kita bisa melihat bahwa kurva ROC dibentuk berdasarkan metrik sensitivity dan specificity yang dihitung dari berbagai macam kemungkinan threshold. Oleh karena itu, kurva ROC ini juga sering digunakan untuk mendapatkan threshold optimal berdasarkan sensitivity dan specificity. \n\nKurva ROC ini biasanya digunakan untuk menentukan model dengan performa prediksi terbaik. Namun, pada ilustrasi ini kita hanya menggunakan satu model sehingga kurva ROC ini kurang bisa digunakan. Tetapi, terdapat metrik yang berbasiskan kurva roc yang bisa digunakan tanpa membandingkan dengan model lain yaitu **AREA Under Curve (AUC)**. \n\n```{r}\npred_reglog %>% \n  roc_auc(truth = truth,estimate_prob)\n```\n\n\n##### Threshold Optimal\n\n\nSelanjutnya kita akan mencoba mendapatkan threshold optimal berdasarkan sensitivity dan specificity menggunakan **Youden's J statistic** yang didefinisikan sebagai berikut\n\n$$\n\\text{Youden's J statistic} = \\text{sensitivity} + \\text{specificity}-1\n$$\n\nSemakin mendekati 1 nilainya maka semakin baik thresholdnya dan semakin nilainya mendekati 0 semakin buruk thresholdnya. Jika kita terapkan pada sintaks adalah sebagai berikut. \n\n\n```{r}\nkurva_roc %>% \n  mutate(youden_index=sensitivity+specificity-1)\n```\n\nkemudian karena kita mencari **Youden's J statistic** yang mendekati satu berarti sama saja kita mencari nilai threshold yang **Youden's J statistic** paling maksimum. Kita bisa mendapatkan nilai maksimum ini dengan bantuan fungsi `slice_max`\n\n\n```{r}\noptimal_thresh <- kurva_roc %>% \n  mutate(youden_index=sensitivity+specificity-1) %>% \n  slice_max(order_by = youden_index)\noptimal_thresh\n```\n\nKemudian hasil prediksi dengan threshold optimal bisa didapatkan dengan sintaks berikut\n\n\n```{r}\npred_reglog2 <- data.frame(estimate_prob=pred_reglog0,truth=test_data$subscribed)\nthreshold2 = optimal_thresh %>% pull(.threshold)\npred_reglog2 <- pred_reglog2 %>% \n  mutate(estimate=if_else(estimate_prob>threshold2,\"yes\",\"no\")) %>% \n  mutate(estimate=factor(estimate,levels=c(\"yes\",\"no\"))) %>% \n  # karena positive class dataset adalah no kita perlu rubah dulu ke yes\n  mutate(truth = factor(truth,levels=c(\"yes\",\"no\")))\npred_reglog2\n```\n\nKemudian jika kita bandingkan antara threshold 0.5 dengan threshold optimal pada beberapa metric maka hasilnya adalah sebagai berikut\n\n\n```{r}\nres_metric2 <- pred_reglog2 %>% \n  multi_metric(truth = truth,estimate = estimate) %>% \n  mutate(threshold=threshold2) %>% \n  relocate(threshold,.after = .metric)\n\nres_metric <- pred_reglog %>% \n  multi_metric(truth = truth,estimate = estimate) %>% \n  mutate(threshold=threshold) %>% \n  relocate(threshold,.after = .metric)\n```\n\n\n\n```{r}\nres_metric2 %>% \n  bind_rows(res_metric) %>% \n  select(-.estimator) %>% \n  pivot_wider(id_cols = .metric,names_from = threshold,\n              names_prefix =\"thres=\", \n              values_from = .estimate)\n```\n\n\n### Prediksi Data Baru\n\n\nuntuk mengilustrasikan prediksi pada data baru, kita akan membuat suatu data baru \"buatan\" dengan mengambil sampel acak dari data `bank_marketing`. Data baru bisanya tidak memuat variabel response sehingga kita akan hilangkan kolom `subscribed`.\n\n\n```{r}\nset.seed(123)\ndata_baru <- bank_marketing %>% \n              slice_sample(n = 10) %>% \n              select(-subscribed)\ndata_baru\n```\n\n\n\n```{r}\npred_data_baru <- predict(mod4,newdata = data_baru,type = \"response\")\n```\n\n```{r}\nthreshold2\npred_data_baru_df <- data.frame(estimate=pred_data_baru) %>% \n                      mutate(estimate=if_else(estimate>threshold2,\"yes\",\"no\")) %>% \n                      mutate(estimate=factor(estimate,levels=c(\"no\",\"yes\")))\npred_data_baru_df\n```\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js","embed-resources":true,"toc":true,"toc-depth":6},"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":{"light":"flatly","dark":"darkly"},"page-layout":"article","comments":{"hypothesis":{"theme":"clean","openSidebar":false}},"title":"Regresi logistik dengan R","date":"11-20-2023","author":"Gerry Alfa Dito","categories":["GLM","R Programming","Statistical Machine Learning"],"draft":false,"image":"post-image.jpeg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}