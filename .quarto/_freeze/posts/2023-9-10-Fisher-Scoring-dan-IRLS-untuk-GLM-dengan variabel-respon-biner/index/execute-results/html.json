{
  "hash": "0e185d633789fd1e4ec27a604eeb23d6",
  "result": {
    "markdown": "---\ntitle: \"Fisher Scoring dan IRLS untuk GLM dengan variabel respon biner\"\ndate: 9-10-2023\nauthor: Gerry Alfa Dito\ncategories: \n      - GLM\n      - R Programming\n      - Computational Statistics\ndraft: false\nimage: preview-image.jpg\n---\n\n\n## Package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(broom)\n```\n:::\n\n\n\n## Fisher Scoring untuk GLM\n\n\nFormula Fisher Scoring yang digunakan untuk mendapatkan penduga bagi koefisien GLM adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\ndengan\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}^{(i)}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)} (\\boldsymbol{D}_{n \\times n}^{(i)})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1}^{(i)})\n$$ \ndan \n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)}=\\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n} ^{(i)}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan Score function $\\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$  dan Expected Fisher Information $\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(0)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} $saat stopping criterion terpenuhi\n\n\n\n## Iteratively reweighted least squares (IRLS) untuk GLM\n\nIRLS untuk GLM merupakan hasil reformulasi dari Fisher Scoring untuk GLM. Berikut proses penurunanya\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+[\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} ]^{−1} \\boldsymbol{S}_{(𝑝+1)×1}^{(i)} \\\\\n   \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}  \\boldsymbol{\\beta}_{(𝑝+1)×1}^{(𝑖+1)}              &= \\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\boldsymbol{S}_{(𝑝+1)×1}^{(i)}\n\\end{aligned}\n$$\n\nkemudiann dengan mensubtitusikan $\\boldsymbol{\\mathcal{I}}_{p\\times p}^{(i)}$ dan $\\boldsymbol{S}_{(𝑝+1)×1}^{(i)}$ sesuai dengan definisi yang ada di fisher scoring, didapat\n\n\n\n$$\n\\begin{aligned}\n \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}              &=  \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\} \\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)}+ \\left[ \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &= \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\left[\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)}) \\right] \\\\\n &\\text{ misal }  \\boldsymbol{z}_{n \\times1}=\\boldsymbol{X}_{(𝑝+1) \\times n}^{t}\\boldsymbol{\\beta}_{((𝑝+1)×1)}^{(i)} + (\\boldsymbol{D}_{n \\times n}^{^{(i)}})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1}^{(i)})  \\\\\n &=\\boldsymbol{X}_{(p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nmaka diperoleh persamaan normal (normal equation) sebagai berikut:\n\n\n\n$$\n\\begin{aligned}\n\\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)} \\right\\} \\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)} &= \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)} \\\\\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  &= \\left\\{ \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{ (p+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n\\end{aligned}\n$$\n\n\n\nKemudian, solusi dari persamaan normal diatas adalah\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\njadi, formulasi untuk IRLS adalah \n\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\nAlgoritme Fisher Scoring dapat dituliskan sebagai berikut:\n\n1. Tentukan perkiraan awal nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(0)}$ dan stopping criterion \n2. Tentukan $\\boldsymbol{W}_{n \\times n}^{(0)}$  dan $\\boldsymbol{z}_{n \\times1}^{(0)}$. \n3. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(0)} \\boldsymbol{z}_{n \\times1}^{(0)}$, sehingga diperoleh perkiraan nilai optimal $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(1)}$\n4. Lakukan Langkah 5 sampai stopping criterion terpenuhi\n5. Hitung $\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{n \\times (p+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}$ untuk iterasi $i=1,2,\\ldots$\n6. Saat stopping criterion terpenuhi maka $\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}$ merupakan nilai penduga bagi parameter $\\boldsymbol{\\beta}_{(p+1) \\times 1}$\n7. Ragam dari $\\boldsymbol{\\beta}_{(p+1) \\times 1}$ diperoleh dengan $Var(\\boldsymbol{\\beta}_{(p+1)})=\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$saat stopping criterion terpenuhi\n\n\n\n\n## Data\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div id=\"bzzkpoysbc\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#bzzkpoysbc table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#bzzkpoysbc thead, #bzzkpoysbc tbody, #bzzkpoysbc tfoot, #bzzkpoysbc tr, #bzzkpoysbc td, #bzzkpoysbc th {\n  border-style: none;\n}\n\n#bzzkpoysbc p {\n  margin: 0;\n  padding: 0;\n}\n\n#bzzkpoysbc .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#bzzkpoysbc .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#bzzkpoysbc .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#bzzkpoysbc .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#bzzkpoysbc .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#bzzkpoysbc .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#bzzkpoysbc .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#bzzkpoysbc .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#bzzkpoysbc .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#bzzkpoysbc .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#bzzkpoysbc .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#bzzkpoysbc .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#bzzkpoysbc .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#bzzkpoysbc .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#bzzkpoysbc .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bzzkpoysbc .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#bzzkpoysbc .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#bzzkpoysbc .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#bzzkpoysbc .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bzzkpoysbc .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#bzzkpoysbc .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bzzkpoysbc .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#bzzkpoysbc .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bzzkpoysbc .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#bzzkpoysbc .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bzzkpoysbc .gt_left {\n  text-align: left;\n}\n\n#bzzkpoysbc .gt_center {\n  text-align: center;\n}\n\n#bzzkpoysbc .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#bzzkpoysbc .gt_font_normal {\n  font-weight: normal;\n}\n\n#bzzkpoysbc .gt_font_bold {\n  font-weight: bold;\n}\n\n#bzzkpoysbc .gt_font_italic {\n  font-style: italic;\n}\n\n#bzzkpoysbc .gt_super {\n  font-size: 65%;\n}\n\n#bzzkpoysbc .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#bzzkpoysbc .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#bzzkpoysbc .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#bzzkpoysbc .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#bzzkpoysbc .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#bzzkpoysbc .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#bzzkpoysbc .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    \n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"No\">No</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Variabel\">Variabel</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Keterangan\">Keterangan</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   1</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">age</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">umur nasabah(numeric)</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   2</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">job</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">jenis pekerjaan nasabah(categorical:\"admin.\",\"unknown\",\"unemployed\",\"management\",\"housemaid\",\"entrepreneur\",\"student\",\"blue-collar\",\"self-employed\",\"retired\",\"technician\",\"services\") </td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   3</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">marital</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">status perkawinan nasabah (categorical: \"married\",\"divorced\",\"single\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   4</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">education</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">tingkat pendidikan(categorical: \"unknown\",\"secondary\",\"primary\",\"tertiary\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   5</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">default</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">apakah nasabah memiliki kredit yang macet? (binary: \"yes\",\"no\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   6</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">balance</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">saldo tahunan rata-rata dalam euros (numeric) </td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   7</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">housing</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">apakah nasabah memiliki cicilan rumah? (binary: \"yes\",\"no\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   8</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">loan</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">apakah nasabah memiliki pinjaman pribadi? (binary: \"yes\",\"no\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   9</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">contact</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">perangkat telekomunikasi (categorical: \"unknown\",\"telephone\",\"cellular\") </td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">   10</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">duration</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">durasi panggilan terakhir, dalam detik (numeric)</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">  11</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">pdays</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\"> banyaknya hari yang telah berlalu setelah klien terakhir kali dihubungi dari campaign sebelumnya (angka, -1 berarti klien tidak dihubungi sebelumnya)</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">  12</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">previous</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">banyaknya komunikasi yang dilakukan sebelum campaign ini(numeric)</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">  13</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">poutcome</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">hasil dari promosi campaign sebelumnya (categorical: \"unknown\",\"other\",\"failure\",\"success\")</td></tr>\n    <tr><td headers=\"No\" class=\"gt_row gt_right\">  14</td>\n<td headers=\"Variabel\" class=\"gt_row gt_left\">subscribed</td>\n<td headers=\"Keterangan\" class=\"gt_row gt_left\">response variable (desired target),apakah nasabah telah berlangganan deposito berjangka? (binary: \"yes\",\"no\")</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\n\nData bisa didownload di link berikut\n\n\n[Download Data](https://drive.google.com/file/d/11e5IwdRsIepcUwS6OQQAdYb6_6mJsKSD/view?usp=drive_link)\n  \n## Import Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbank_marketing <- read.csv(\"bank_marketing.csv\",stringsAsFactors = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(bank_marketing)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 45,211\nColumns: 14\n$ subscribed <fct> no, no, no, no, no, no, no, no, no, no, no, no, no, no, no,…\n$ age        <int> 58, 44, 33, 47, 33, 35, 28, 42, 58, 43, 41, 29, 53, 58, 57,…\n$ job        <fct> management, technician, entrepreneur, blue-collar, unknown,…\n$ marital    <fct> married, single, married, married, single, married, single,…\n$ education  <fct> tertiary, secondary, secondary, unknown, unknown, tertiary,…\n$ default    <fct> no, no, no, no, no, no, no, yes, no, no, no, no, no, no, no…\n$ balance    <int> 2143, 29, 2, 1506, 1, 231, 447, 2, 121, 593, 270, 390, 6, 7…\n$ housing    <fct> yes, yes, yes, yes, no, yes, yes, yes, yes, yes, yes, yes, …\n$ loan       <fct> no, no, yes, no, no, no, yes, no, no, no, no, no, no, no, n…\n$ contact    <fct> unknown, unknown, unknown, unknown, unknown, unknown, unkno…\n$ duration   <int> 261, 151, 76, 92, 198, 139, 217, 380, 50, 55, 222, 137, 517…\n$ pdays      <int> -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,…\n$ previous   <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ poutcome   <fct> unknown, unknown, unknown, unknown, unknown, unknown, unkno…\n```\n:::\n:::\n\n\n\n## Fisher Scoring dan IRLS untuk Binomial GLM\n\n\nMisal Binomial GLM didefinisikan sebagai\n\n\n$$\n\\boldsymbol{\\pi} = \\frac{\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}{1+\\exp{( \\boldsymbol{X}\\boldsymbol{\\beta} )}}\n$$\natau\n\n$$\n\\text{logit}(\\boldsymbol{\\pi}) = \\log{ \\left( \\frac{\\boldsymbol{\\pi}}{1-\\boldsymbol{\\pi}} \\right)}= \\boldsymbol{X}\\boldsymbol{\\beta} \n$$\ndengan \n\n$$\n\\boldsymbol{\\pi}=P(\\boldsymbol{y}=1)\n$$\n\n\nUntuk ilustrasi penggunaan Fisher-scoring dan IRLS kita akan menggunakan variabel prediktor `balance`, `age`, `housing` dan `marital`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2045)\nbank_marketing_mini <-  bank_marketing %>% \n                            select(subscribed,balance,age,housing,marital) %>% \n                            slice_sample(n=250,by = subscribed)\nglimpse(bank_marketing_mini)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 500\nColumns: 5\n$ subscribed <fct> no, no, no, no, no, no, no, no, no, no, no, no, no, no, no,…\n$ balance    <int> 354, 5838, 39, -123, 1150, 263, -11, 1733, 14, 416, 2, 0, 4…\n$ age        <int> 29, 56, 55, 35, 33, 40, 51, 33, 50, 34, 26, 27, 32, 23, 45,…\n$ housing    <fct> yes, no, no, yes, yes, yes, no, yes, yes, no, yes, yes, yes…\n$ marital    <fct> single, married, married, single, single, single, married, …\n```\n:::\n:::\n\n\n\nKemudian kita akan ekstrak matriks modelnya $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- model.matrix(subscribed~balance+age+housing+marital,data = bank_marketing_mini)\n#dimensi matrix X\ndim(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   6\n```\n:::\n:::\n\n\n\ndan kemudian untuk $\\boldsymbol{y}_{n\\times 1}$, kita misalkan kategori `yes` sebagai 1 dan 0 adalah untuk kategori `no`  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- ifelse(bank_marketing_mini$subscribed==\"yes\",1,0)\n# ukuran variabel respon\nlength(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500\n```\n:::\n\n```{.r .cell-code}\n# banyaknya nilai 1 dan 0\ntable(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny\n  0   1 \n250 250 \n```\n:::\n:::\n\n\nberikut overview dari matriks $\\boldsymbol{X}_{n \\times (p+1)}$ \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX[1:10,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept) balance age housingyes maritalmarried maritalsingle\n1            1     354  29          1              0             1\n2            1    5838  56          0              1             0\n3            1      39  55          0              1             0\n4            1    -123  35          1              0             1\n5            1    1150  33          1              0             1\n6            1     263  40          1              0             1\n7            1     -11  51          0              1             0\n8            1    1733  33          1              0             1\n9            1      14  50          1              1             0\n10           1     416  34          0              0             1\n```\n:::\n:::\n\n\n\n### Binomial sebagai distribusi keluarga eksponensial\n\nSelanjutnya kita akan mendefinisikan matriks-matriks lain yang dibutuhkan untuk fisher scoring dan IRLS. Pertama-tama kita ingat terlebih dahulu tentang distribusi binomail sebagai distribusi keluarga eksponensial.\n\nDistribusi Binomial yang digunakan untuk GLM adalah $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$. Ingat bahwa, Cumulant function $b(\\theta)$ untuk $Y \\sim\\frac{\\text{Binomial}(m,\\pi)}{m}$ adalah\n\n\n$$\nb(\\theta) = \\log{[1 + \\exp{(\\theta})]}\n$$\n\n\ndan parameter dispersi $a(\\phi)$\n\n\n\n$$\na(\\phi)=\\frac{1}{m}\n$$\n\n\nKemudian, $\\mu$ dan $Var(Y)$ dari $Y\\frac{\\text{Binomial}(m,\\pi)}{m}$ sebagai keluarga eksponensial adalah\n\n\n$$\n\\begin{aligned}\n\\mu=E(Y)    &= \\frac{d b(\\theta)}{d\\theta} \\\\\n            &=\\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}}\n\\end{aligned}\n$$\n\ndan\n\n$$\n\\begin{aligned}\n\nVar(Y) &= Var(\\mu) a(\\phi) \\\\\n       &=  \\frac{d ^{2}b(\\theta)}{d\\theta^{2}} a(\\phi)\\\\\n       &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m}\n\\end{aligned}\n$$\n\nIngat bahwa koneksi (pemisalan) $\\theta$ dengan parameter $\\pi$ adalah sebagai berikut\n\n\n$$\n\\theta            =    \\log{ \\left( \\frac{\\pi}{1-\\pi} \\right)} \n$$\n\nJika kita subtitusi ke dalam $\\mu$ dan $Var(Y)$\n\n\n$$\n\\begin{aligned}\n\\mu &= \\frac{\\exp{(\\theta)}}{1+\\exp{(\\theta)}} \\\\\n    &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{1 +  \\left( \\frac{\\pi}{1-\\pi} \\right)} \\\\\n    &= \\pi\n\\end{aligned}\n$$\n\n\n$$\n\\begin{aligned}\nVar(Y) &= \\frac{\\exp{(\\theta)}}{[1+\\exp{(\\theta)}]^{2}} \\frac{1}{m} \\\\\n       &= \\frac{ \\left( \\frac{\\pi}{1-\\pi} \\right) }{ \\left[1 +  \\left( \\frac{\\pi}{1-\\pi} \\right) \\right]^{2}} \\frac{1}{m} \\\\\n       &= \\pi (1-\\pi) \\frac{1}{m} \\\\\n       &= \\frac{\\pi (1-\\pi)}{m}\n\\end{aligned}\n$$\n\n\njadi $\\mu=\\pi$ dan $Var(Y)=\\frac{\\pi (1-\\pi)}{m}$. Kemudian, fungsi hubung (link function) yang digunakan adalah fungsi hubung kanonik (canonical link function) yaitu\n\n\n$$\n\\eta=\\text{logit}(\\mu)=\\text{logit}(\\pi)=\\log{\\left( \\frac{\\pi}{1-\\pi} \\right)}\n$$\n\njika kita ubah menjadi fungsi dari $\\eta$\n\n$$\ng^{-1}(\\eta)=\\mu=\\pi = \\frac{\\exp{(\\eta)}}{1+\\exp{(\\eta)}}\n$$\n\n\n\n### Mendefiniskan matriks untuk Fisher Scoring dan IRLS\n\n\nKemudian kita akan dapatkan matriks $\\boldsymbol{W}_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{W}_{n \\times n} = \\begin{bmatrix}\n \\frac{\\left(\\frac{d \\mu_{1}}{d\\eta_{1}} \\right)^{2}}{Var(y_{1})}  & 0 & \\ldots & 0 \\\\\n 0 & \\frac{\\left(\\frac{d \\mu_{2}}{d\\eta_{2}} \\right)^{2}}{Var(y_{2})}  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{\\left(\\frac{d \\mu_{n}}{d\\eta_{2}} \\right)^{2}}{Var(y_{n})}\n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\ndan \n\n\n$$\nVar(y_{i})= \\frac{\\pi_i (1-\\pi_i)}{m_i}\n$$\n\n\nsehingga\n\n\n$$\n\\frac{\\left(\\frac{d \\mu_{i}}{d\\eta_{i}} \\right)^{2}}{Var(y_{i})} = \\frac{[\\pi_i (1-\\pi_i)]^{2}}{\\frac{\\pi_i (1-\\pi_i)}{m_i}} = m_i\\pi_i (1-\\pi_i)\n$$\n\n\n\nJadi matriks $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{W}_{n \\times n}= \\begin{bmatrix}\n m_{1}\\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & m_{2}\\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & m_{n}\\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\nkita tuliskan matriks $\\boldsymbol{W}_{n \\times n}$ dalam sintaks R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n:::\n\n\n\nmisalkan  $m_1=m_2=m_3=1$ dan $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{W}_{n \\times n}$ adalah\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nW(m=c(1,1,1),pi=c(0.5,0.6,0.7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 x 3 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3]\n[1,] 0.25    .    .\n[2,]    . 0.24    .\n[3,]    .    . 0.21\n```\n:::\n:::\n\n\n\nSelanjutnya kita akan dapatkan matriks $D_{n \\times n}$ yang didefinisikan\n\n\n$$\n\\boldsymbol{D}_{n \\times n} = \\begin{bmatrix}\n \\frac{d \\mu_{1}}{d\\eta_{1}}   & 0 & \\ldots & 0 \\\\\n 0 & \\frac{d \\mu_{2}}{d\\eta_{2}}   & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\frac{d \\mu_{n}}{d\\eta_{n}} \n\\end{bmatrix}\n$$\n\nelemen-elemen diagonalnya sebagai berikut:\n\n$$\n\\begin{aligned}\n\\frac{d \\mu_{i}}{d\\eta_{i}} =\\frac{d \\pi_{i}}{d\\eta_{i}} \n        &= \\frac{d \\left( \\frac{\\exp{(\\eta_i)}}{1+\\exp{(\\eta_i)}} \\right)}{d\\eta_{i}} \\\\ \n        &=  \\frac{\\exp{(\\eta_i)}}{[1+\\exp{(\\eta_i)}]^{2}} \\\\\n        &=  \\frac{ \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) }{ \\left[1 +  \\left( \\frac{\\pi_i}{1-\\pi_i} \\right) \\right]^{2}}\\\\\n       &= \\pi_i (1-\\pi_i)\n\\end{aligned}\n$$\n\n\n\nJadi matriks $\\boldsymbol{D}_{n \\times n}$ adalah\n\n\n$$\n\\boldsymbol{D}_{n \\times n}= \\begin{bmatrix}\n \\pi_1 (1-\\pi_1)  & 0 & \\ldots & 0 \\\\\n 0 & \\pi_2 (1-\\pi_2)  & \\ldots & 0 \\\\\n \\vdots & \\vdots                                                       & \\ddots & \\vdots \\\\ \n 0      &                           0                                  & 0      & \\pi_n (1-\\pi_n)\n\\end{bmatrix}\n$$\n\n\nkita tuliskan matriks $\\boldsymbol{D}_{n \\times n}$ dalam sintaks R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n:::\n\n\nmisalkan  $\\pi_{1}=0.5,\\pi_{2}=0.6,\\pi_{3}=0.7$ maka $\\boldsymbol{D}_{n \\times n}$ adalah\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD(pi=c(0.5,0.6,0.7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 x 3 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3]\n[1,] 0.25    .    .\n[2,]    . 0.24    .\n[3,]    .    . 0.21\n```\n:::\n:::\n\n\n\n\nSelanjutnya kita akan dapatkan matriks $\\boldsymbol{\\mu}_{n \\times 1}$ yang didefinisikan\n\n$$\n\\boldsymbol{\\mu}_{n \\times 1}=g^{-1}(\\boldsymbol{X}\\boldsymbol{\\beta})=\\frac{\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}{1+\\exp{(\\boldsymbol{X}_{n \\times (p+1)}\\boldsymbol{\\beta}_{(p+1)})}}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n:::\n\n\nmisalkan  $\\boldsymbol{X}_{n \\times (p+1)}$ berasal dari data `bank_marketing_mini` dan $\\boldsymbol{\\beta}_{(p+1)}=[0.230  0.001 \\space 0.002 \\space -0.769 \\space -0.166 \\space 0.109]^{t}$ maka $\\boldsymbol{\\mu}_{n \\times 1}$ adalah\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# memeriksa dimensi\ndim( mu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   1\n```\n:::\n\n```{.r .cell-code}\n# menampilkan 10 elemen pertama\nmu(X=X,beta = c(0.230,0.001,0.002,-0.769,-0.166,0.109) )[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.4955001 0.9975617 0.5530496 0.3815440 0.6869718 0.4782637 0.5386726\n [8] 0.7972185 0.3564054 0.6948728\n```\n:::\n:::\n\n\n\n### Fisher Scoring\n\n\n\nmatriks $\\boldsymbol{S}_{(p+1) \\times 1}$ adalah\n\n\n$$\n\\boldsymbol{S}_{(p+1) \\times 1}= \\boldsymbol{X}^{t}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}-\\boldsymbol{\\mu}_{n \\times 1})\n$$   \n\n\nkita tuliskan matriks $\\boldsymbol{S}_{(p+1) \\times 1}$ dalam sintaks R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n:::\n\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500 500\n```\n:::\n\n```{.r .cell-code}\nW_coba[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.25    .    .    .    .\n[2,]    . 0.25    .    .    .\n[3,]    .    . 0.25    .    .\n[4,]    .    .    . 0.25    .\n[5,]    .    .    .    . 0.25\n```\n:::\n\n```{.r .cell-code}\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(D_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500 500\n```\n:::\n\n```{.r .cell-code}\nD_coba[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.25    .    .    .    .\n[2,]    . 0.25    .    .    .\n[3,]    .    . 0.25    .    .\n[4,]    .    .    . 0.25    .\n[5,]    .    .    .    . 0.25\n```\n:::\n\n```{.r .cell-code}\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   1\n```\n:::\n\n```{.r .cell-code}\nhead(mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,] 0.77550659\n[2,] 0.94264755\n[3,] 0.47241345\n[4,] 0.08665263\n[5,] 0.63646300\n[6,] 0.42453500\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nS(X = X,W = W_coba,D = D_coba,y = y,mu = mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 1 Matrix of class \"dgeMatrix\"\n                      [,1]\n(Intercept)       -5.12588\nbalance        64379.67806\nage             -132.00826\nhousingyes       -27.00537\nmaritalmarried    -9.45959\nmaritalsingle      5.37219\n```\n:::\n:::\n\n\n\nmatriks $\\boldsymbol{\\mathcal{I}}_{p \\times p}$ adalah\n\n\n$$\n\\boldsymbol{\\mathcal{I}}_{p \\times p }=\\boldsymbol{X}_{ (p+1) \\times n} \\boldsymbol{W}_{n \\times n}  \\boldsymbol{X}_{n \\times (p+1)} \n$$\n\nkita tuliskan matriks $\\boldsymbol{\\mathcal{I}}_{p \\times p }$ dalam sintaks R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500 500\n```\n:::\n\n```{.r .cell-code}\nW_coba[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.25    .    .    .    .\n[2,]    . 0.25    .    .    .\n[3,]    .    . 0.25    .    .\n[4,]    .    .    . 0.25    .\n[5,]    .    .    .    . 0.25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nI_fs(X = X,W = W_coba)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 Matrix of class \"dgeMatrix\"\n               (Intercept)      balance        age housingyes maritalmarried\n(Intercept)          125.0 1.901443e+05    5160.00      58.00          68.50\nbalance           190144.2 1.821748e+09 8400186.75   59549.75      101843.00\nage                 5160.0 8.400187e+06  230156.50    2279.50        3062.25\nhousingyes            58.0 5.954975e+04    2279.50      58.00          31.00\nmaritalmarried        68.5 1.018430e+05    3062.25      31.00          68.50\n```\n:::\n:::\n\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- function(X,W,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n crossprod( X, W %*% inv_D %*% (y-mu) )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nI_fs <- function(X,W){\n crossprod(X,W %*% X)\n}\n```\n:::\n\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi fisher scoring\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n    V1   V2\n1 0.01 0.01\n\n$status\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n     V1    V2\n1 1e-05 1e-05\n\n$status\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n     V1    V2\n1 1e-04 1e-05\n\n$status\n[1] FALSE\n```\n:::\n:::\n\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$, nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept)        balance            age     housingyes maritalmarried \n             0              0              0              0              0 \n maritalsingle \n             0 \n```\n:::\n\n```{.r .cell-code}\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n:::\n\n\n\nIngat Formula Fisher Scoring yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i+1)}=\\boldsymbol{\\beta}_{(p+1) \\times 1}^{(i)} + \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p }^{(i)} \\right]^{-1} \\boldsymbol{S}_{(p+1) \\times 1}^{(i)}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  I_inv <- chol2inv(chol( I_fs(X = X,W = W_new) ))\n  \n  #formulasi fisher scoring\n  beta_new <- beta_new +I_inv %*% S(X=X,W = W_new,D = D_new,y =y ,mu = mu_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n:::\n\n\n\n\nSaat Convergent maka kita mendapatkan\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})= \\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}\n$$\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left[\\boldsymbol{\\mathcal{I}}_{p \\times p } \\right]^{-1}$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_fs <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=I_inv)\nresult_fs$iter_convergence\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 31\n```\n:::\n\n```{.r .cell-code}\nresult_fs$var_beta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 6 Matrix of class \"dpoMatrix\"\n                 (Intercept)       balance           age    housingyes\n(Intercept)     2.743637e-01 -5.891964e-07 -4.050466e-03 -3.584211e-02\nbalance        -5.891964e-07  1.308069e-09 -3.003060e-08  6.255880e-07\nage            -4.050466e-03 -3.003060e-08  8.377425e-05  3.146135e-04\nhousingyes     -3.584211e-02  6.255880e-07  3.146135e-04  3.568298e-02\nmaritalmarried -7.623728e-02 -2.022522e-07  2.006810e-04  5.139815e-03\nmaritalsingle  -1.230458e-01 -4.027429e-07  1.169965e-03  8.360438e-03\n               maritalmarried maritalsingle\n(Intercept)     -7.623728e-02 -1.230458e-01\nbalance         -2.022522e-07 -4.027429e-07\nage              2.006810e-04  1.169965e-03\nhousingyes       5.139815e-03  8.360438e-03\nmaritalmarried   8.060487e-02  6.751034e-02\nmaritalsingle    6.751034e-02  1.072151e-01\n```\n:::\n\n```{.r .cell-code}\nsummary_fs <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_fs$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_fs$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_fs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       variables      Estimate      Std_Err          z p_value\n1    (Intercept)  0.2300633445 0.5237974260  0.4392220   0.661\n2        balance  0.0000557833 0.0000361672  1.5423726   0.123\n3            age  0.0024653247 0.0091528273  0.2693512   0.788\n4     housingyes -0.7690447815 0.1888993831 -4.0711874   0.000\n5 maritalmarried -0.1661114916 0.2839099667 -0.5850851   0.558\n6  maritalsingle  0.1087506638 0.3274371898  0.3321268   0.740\n```\n:::\n:::\n\n\n\n\n\n### IRLS\n\n\nmatriks $\\boldsymbol{z}$ adalah\n\n\n$$\n\\boldsymbol{z}_{n \\times 1}=\\boldsymbol{X}_{ n \\times (p+1) }\\boldsymbol{\\beta}_{((𝑝+1)×1)} + (\\boldsymbol{D}_{n \\times n})^{-1} (\\boldsymbol{y}_{n \\times 1}−\\boldsymbol{\\mu}_{𝑛×1})\n$$\n\nkita tuliskan matriks $\\boldsymbol{z}$ dalam sintaks R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n:::\n\n\n\nmisalkan  $\\boldsymbol{W}_{n \\times n} ,\\boldsymbol{\\beta}_{((𝑝+1)×1)},\\boldsymbol{D}_{n \\times n}$ dan $\\boldsymbol{\\mu}_{n \\times 1}$ adalah sebagai berikut:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2045)\n\nW_coba <- W(m = 1,pi = rep(0.5,nrow(X)))\ndim(W_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500 500\n```\n:::\n\n```{.r .cell-code}\nW_coba[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.25    .    .    .    .\n[2,]    . 0.25    .    .    .\n[3,]    .    . 0.25    .    .\n[4,]    .    .    . 0.25    .\n[5,]    .    .    .    . 0.25\n```\n:::\n\n```{.r .cell-code}\nbeta_coba <- c(0.230,0.001,0.002,-0.769,-0.166,0.109)\nbeta_coba\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.230  0.001  0.002 -0.769 -0.166  0.109\n```\n:::\n\n```{.r .cell-code}\nD_coba <- D(pi = rep(0.5,nrow(X)))\ndim(mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   1\n```\n:::\n\n```{.r .cell-code}\nD_coba[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.25    .    .    .    .\n[2,]    . 0.25    .    .    .\n[3,]    .    . 0.25    .    .\n[4,]    .    .    . 0.25    .\n[5,]    .    .    .    . 0.25\n```\n:::\n\n```{.r .cell-code}\nmu_coba <- as.matrix( runif(n = nrow(X),min = 0,max = 1 ) )\ndim(mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   1\n```\n:::\n\n```{.r .cell-code}\nhead(mu_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,] 0.77550659\n[2,] 0.94264755\n[3,] 0.47241345\n[4,] 0.08665263\n[5,] 0.63646300\n[6,] 0.42453500\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nz_coba <- z(X = X,beta = beta_coba,D = D_coba,y = y,mu = mu_coba)\ndim(z_coba)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500   1\n```\n:::\n\n```{.r .cell-code}\nz_coba[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -3.1200264  2.2434098 -1.6766538 -0.8296105 -1.7598520 -1.7851400\n [7] -3.2987687 -1.1895575 -1.5743409  0.1808609\n```\n:::\n:::\n\n\n\n\n\n\nSupaya lebih mudah, kita kumpulkan semua definisi matriks yang sudah dituliskan ke program R dibawah ini\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmu <- function(X,beta){\n  exp(X %*% beta) / ( 1+exp( X%*% beta) )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nW <- function(m,pi){\nwi <- m * pi * ( 1- pi )\nDiagonal(x=as.numeric(wi))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- function(pi){\ndi <- pi * ( 1- pi )\nDiagonal(x=as.numeric(di))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- function(X,beta,D,y,mu){\n  inv_D <- chol2inv(chol(D))\n X %*% beta + inv_D %*%  (y-mu)\n}\n```\n:::\n\n\n\nSelanjutnya kita akan mulai menuliskan program R untuk iterasi IRLS\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion <- function(beta_old,beta_new,tol) {\n  error <- as.matrix(abs(beta_new-beta_old))\n  status <- all(error  < tol)\n  return(list(error=as.data.frame(t(error)),status=status))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.51,-0.91),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n    V1   V2\n1 0.01 0.01\n\n$status\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.50001,-0.90001),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n     V1    V2\n1 1e-05 1e-05\n\n$status\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstop_criterion(beta_old = c(0.5,-0.9),beta_new = c(0.5001,-0.90001),tol = 1e-5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n     V1    V2\n1 1e-04 1e-05\n\n$status\n[1] FALSE\n```\n:::\n:::\n\n\n\nberikut adalah nilai awal dari $\\boldsymbol{\\beta}_{(p+1)}$ nilai toleransi, iterasi maksimum dan nilai dari $m_i$. Khusus untuk $m_i=1$ karena respon `subscribed` adalah respon distribusi bernouli.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta_new <- rep(0,ncol(X))\nnames(beta_new) <- colnames(X)\nbeta_new\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept)        balance            age     housingyes maritalmarried \n             0              0              0              0              0 \n maritalsingle \n             0 \n```\n:::\n\n```{.r .cell-code}\nmax_iter <- 1000\nmi <- 1\n\ntolerance <-  1e-15\n```\n:::\n\n\n\nIngat Formula IRLS yang digunakan adalah sebagai berikut:\n\n\n$$\n\\boldsymbol{\\beta}_{(p+1)×1}^{(𝑖+1)}  = \\left\\{ \\boldsymbol{X}_{(𝑝+1) \\times n }^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1} \\boldsymbol{X}_{(𝑝+1) \\times n}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{z}_{n \\times1}^{(i)}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:max_iter){\n  \n  #menyimpan beta lama\n  beta_old <- beta_new\n  \n  mu_new <- mu(X = X,beta = beta_new)\n  W_new <- W(m = mi,pi = mu_new)\n  D_new <- D(pi = mu_new)\n  \n  z_new <- z(X = X,beta = beta_new,D = D_new,y = y,mu = mu_new)\n  inv_XWX <- chol2inv(chol(crossprod(X,W_new %*% X)))\n  \n  #formulasi fisher scoring\n  beta_new <- inv_XWX %*% crossprod(X,W_new %*% z_new) \n  \n\n  #menghitung stopping criterion\n  stop_criterion_iter <- stop_criterion(\n                 beta_old = beta_old,\n                 beta_new = beta_new,\n                 tol = tolerance)\n  \n\n  \n  #iterasi berhenti jika sudah memenuhi stopping criterion\n  if(stop_criterion_iter$status) break\n}\n```\n:::\n\n\n\n\nSaat Convergent maka kita mendapatkan\n\n\n$$\nVar(\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1})=  \\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}\n$$\n\nkemudian standard error dari $\\hat{\\boldsymbol{\\beta}}_{(p+1) \\times 1}$ adalah akar dari diagonal utama  $\\left\\{ \\boldsymbol{X}_{n \\times (𝑝+1)}^{t} \\boldsymbol{W}_{n \\times n}^{(i)} \\boldsymbol{X}_{n \\times (𝑝+1)}  \\right\\}^{-1}$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_irls <- list(iter_convergence=i,coefficients=as.numeric(beta_new),var_beta=inv_XWX)\nresult_irls$iter_convergence\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33\n```\n:::\n\n```{.r .cell-code}\nresult_irls$var_beta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 6 Matrix of class \"dpoMatrix\"\n                 (Intercept)       balance           age    housingyes\n(Intercept)     2.743637e-01 -5.891964e-07 -4.050466e-03 -3.584211e-02\nbalance        -5.891964e-07  1.308069e-09 -3.003060e-08  6.255880e-07\nage            -4.050466e-03 -3.003060e-08  8.377425e-05  3.146135e-04\nhousingyes     -3.584211e-02  6.255880e-07  3.146135e-04  3.568298e-02\nmaritalmarried -7.623728e-02 -2.022522e-07  2.006810e-04  5.139815e-03\nmaritalsingle  -1.230458e-01 -4.027429e-07  1.169965e-03  8.360438e-03\n               maritalmarried maritalsingle\n(Intercept)     -7.623728e-02 -1.230458e-01\nbalance         -2.022522e-07 -4.027429e-07\nage              2.006810e-04  1.169965e-03\nhousingyes       5.139815e-03  8.360438e-03\nmaritalmarried   8.060487e-02  6.751034e-02\nmaritalsingle    6.751034e-02  1.072151e-01\n```\n:::\n\n```{.r .cell-code}\nsummary_irls <- data.frame(variables=rownames(beta_new),\n                         Estimate=round(result_irls$coefficients,10),\n                         Std_Err=round(sqrt(diag(as.matrix(result_irls$var_beta))),10),row.names = NULL) %>% \n              mutate(z=Estimate / Std_Err, p_value=round(2*pnorm(q=abs(z),lower.tail = F),3))\nsummary_irls\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       variables      Estimate      Std_Err          z p_value\n1    (Intercept)  0.2300633445 0.5237974260  0.4392220   0.661\n2        balance  0.0000557833 0.0000361672  1.5423726   0.123\n3            age  0.0024653247 0.0091528273  0.2693512   0.788\n4     housingyes -0.7690447815 0.1888993831 -4.0711874   0.000\n5 maritalmarried -0.1661114916 0.2839099667 -0.5850851   0.558\n6  maritalsingle  0.1087506638 0.3274371898  0.3321268   0.740\n```\n:::\n:::\n\n\n\n### Default fungsi R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod1 <- glm(formula = subscribed~.,\n            data = bank_marketing_mini,\n            family = binomial(link = \"logit\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(mod1) %>% \n  mutate(across(where(is.numeric),function(x) round(x,7)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  term             estimate std.error statistic   p.value\n  <chr>               <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)     0.230     0.524         0.439 0.661    \n2 balance         0.0000558 0.0000362     1.54  0.123    \n3 age             0.00247   0.00915       0.269 0.788    \n4 housingyes     -0.769     0.189        -4.07  0.0000468\n5 maritalmarried -0.166     0.284        -0.585 0.558    \n6 maritalsingle   0.109     0.327         0.332 0.740    \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}